<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PaperCut</title>
<link rel="icon" type="image/png" href="/static/favicon.png">
<link rel="apple-touch-icon" href="/static/icon.png">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --blue: #48A8DD;
  --blue-light: #e8f4fb;
  --blue-pale: #f2f9fd;
  --green: #61B87B;
  --green-light: #eaf6ee;
  --sunray: #EDAE49;
  --sunray-light: #fdf5e6;
  --brick: #D1495B;
  --brick-light: #fbeaec;
  --indigo: #003D5B;
  --ink: #011627;
  --bg: #FDFFFC;
  --bg-page: #F7F8F5;
  --bg-surface: #FFFFFF;
  --border: #E2E4DE;
  --border-light: #EEEFE9;
  --text: #1A1F2B;
  --text-secondary: #5A6275;
  --text-dim: #8E94A4;
  --font-display: 'DM Sans', system-ui, sans-serif;
  --font-script: 'Courier Prime', 'Courier New', Courier, monospace;
  --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
  --radius: 8px;
  --radius-lg: 12px;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.10);
}

[data-theme="dark"] {
  --blue: #5BB8E8;
  --blue-light: #1a2e3d;
  --blue-pale: #141f2b;
  --green: #6FC88B;
  --green-light: #1a2d1f;
  --sunray: #F0BC5E;
  --sunray-light: #2b2415;
  --brick: #E05A6C;
  --brick-light: #2d1a1e;
  --indigo: #a8c8dc;
  --ink: #0d1117;
  --bg: #161b22;
  --bg-page: #0d1117;
  --bg-surface: #161b22;
  --border: #30363d;
  --border-light: #21262d;
  --text: #e6edf3;
  --text-secondary: #8b949e;
  --text-dim: #6e7681;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.5);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: var(--font-display);
  background: var(--bg-page);
  color: var(--text);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
}

.hidden { display: none !important; }

/* ── Layout ── */
.container {
  max-width: 960px;
  margin: 0 auto;
  padding: 0 24px;
}
.container-wide {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 24px;
}

/* ── Header ── */
header {
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  padding: 16px 0;
}
header .container-wide {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
header h1 {
  font-family: var(--font-display);
  font-size: 18px;
  font-weight: 600;
  color: var(--indigo);
}
header h1 span { color: var(--blue); }
#settingsToggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 6px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-display);
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}
#settingsToggle:hover {
  border-color: var(--blue);
  color: var(--blue);
}

/* ── Settings Overlay ── */
.settings-overlay {
  position: fixed;
  inset: 0;
  background: rgba(1, 22, 39, 0.4);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.15s ease-out;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
.settings-panel {
  background: var(--bg-surface);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  width: 580px;
  max-height: 85vh;
  overflow-y: auto;
  animation: slideUp 0.2s ease-out;
}
@keyframes slideUp {
  from { opacity: 0; transform: translateY(12px); }
  to { opacity: 1; transform: translateY(0); }
}
.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: 1px solid var(--border-light);
}
.settings-header h2 {
  font-size: 16px;
  font-weight: 600;
  color: var(--indigo);
}
.settings-close {
  background: none;
  border: none;
  font-size: 20px;
  color: var(--text-dim);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  line-height: 1;
}
.settings-close:hover { background: var(--bg-page); color: var(--text); }
.settings-body {
  padding: 24px;
}
.settings-section {
  margin-bottom: 24px;
}
.settings-section:last-child { margin-bottom: 0; }
.settings-section-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border-light);
}
.settings-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
}
.settings-field {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.settings-field.full-width {
  grid-column: 1 / -1;
}
.settings-field label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}
.settings-field input,
.settings-field select {
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text);
  background: var(--bg-surface);
  transition: border-color 0.15s;
}
.settings-field input:focus,
.settings-field select:focus { outline: none; border-color: var(--blue); }
.settings-field .hint {
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.4;
}
.settings-footer {
  padding: 16px 24px;
  border-top: 1px solid var(--border-light);
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

/* ── Drop Zone ── */
.drop-zone-wrap {
  padding: 32px 0 24px;
}
.drop-zone {
  border: 2px dashed var(--border);
  border-radius: var(--radius-lg);
  padding: 48px 24px;
  text-align: center;
  transition: all 0.2s;
  cursor: pointer;
  background: var(--bg-surface);
}
.drop-zone.dragover {
  border-color: var(--blue);
  background: var(--blue-pale);
  box-shadow: 0 0 0 4px rgba(72, 168, 221, 0.1);
}
.drop-zone.uploading { pointer-events: none; opacity: 0.7; }
.drop-zone-icon {
  font-size: 36px;
  margin-bottom: 12px;
  color: var(--text-dim);
}
.drop-zone-text {
  font-size: 15px;
  color: var(--text-secondary);
  margin-bottom: 6px;
}
.drop-zone-text strong { color: var(--blue); }
.drop-zone-hint {
  font-size: 12px;
  color: var(--text-dim);
}
.drop-zone-file-input { display: none; }
.drop-alt {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.drop-alt-divider {
  font-size: 12px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}
.path-input {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 14px;
  border-radius: 6px;
  font-family: var(--font-mono);
  font-size: 12px;
  width: 360px;
  transition: border-color 0.15s;
}
.path-input:focus { outline: none; border-color: var(--blue); }

/* ── Buttons ── */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-display);
  font-weight: 500;
  font-size: 13px;
  border: none;
  transition: all 0.15s;
  white-space: nowrap;
}
.btn-primary {
  background: var(--blue);
  color: #fff;
}
.btn-primary:hover { background: #3a9ad0; }
.btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-secondary {
  background: var(--bg-surface);
  color: var(--text-secondary);
  border: 1px solid var(--border);
}
.btn-secondary:hover { border-color: var(--blue); color: var(--blue); }
.btn-danger-outline {
  background: none;
  color: var(--brick);
  border: 1px solid var(--brick-light);
}
.btn-danger-outline:hover {
  background: var(--brick-light);
  border-color: var(--brick);
}
.btn-success-outline {
  background: none;
  color: var(--green);
  border: 1px solid var(--green-light);
}
.btn-success-outline:hover {
  background: var(--green-light);
  border-color: var(--green);
}
.btn-sm { padding: 5px 12px; font-size: 12px; }

/* ── Progress Log ── */
#progress-section { padding: 0 0 24px; }
#progress-log {
  background: var(--ink);
  color: #b0bec5;
  border-radius: var(--radius);
  padding: 16px;
  font-family: var(--font-mono);
  font-size: 12px;
  max-height: 180px;
  overflow-y: auto;
  line-height: 1.7;
}
#progress-log .line { white-space: pre-wrap; word-break: break-all; }
#progress-log .line::before { content: "> "; color: #546e7a; }
#progress-log .line-error { color: var(--brick); }
#progress-log .line-error::before { content: "! "; color: var(--brick); }
#progress-log .line-done { color: var(--green); }
#progress-log .line-done::before { content: "\2713 "; color: var(--green); }

/* ── Video Section ── */
#video-section { padding-bottom: 0; }
.video-wrap {
  background: #000;
  border-radius: var(--radius-lg);
  overflow: hidden;
  box-shadow: var(--shadow-lg);
}
video { width: 100%; display: block; max-height: 400px; }
.audio-only .video-wrap { background: var(--bg-surface); border: 1px solid var(--border); }
.audio-only video { height: 54px; }

.video-toolbar {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 10px 0 0;
}
.video-toolbar label {
  font-size: 12px;
  color: var(--text-dim);
  display: flex;
  align-items: center;
  gap: 5px;
  cursor: pointer;
}
.video-toolbar input[type="checkbox"] { accent-color: var(--blue); }

/* ── Stats Bar ── */
#summary-bar {
  display: flex;
  gap: 0;
  margin: 20px 0;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  box-shadow: var(--shadow-sm);
}
.stat-card {
  flex: 1;
  padding: 14px 18px;
  text-align: center;
  border-right: 1px solid var(--border-light);
}
.stat-card:last-child { border-right: none; }
.stat-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  color: var(--text-dim);
  margin-bottom: 4px;
}
.stat-val {
  font-family: var(--font-mono);
  font-size: 20px;
  font-weight: 500;
  color: var(--indigo);
}
.stat-card.stat-danger .stat-val { color: var(--brick); }
.stat-card.stat-accent .stat-val { color: var(--blue); }

/* ── Transcript Two-Column ── */
#transcript-section { padding-bottom: 24px; }
.transcript-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.transcript-col-headers {
  display: flex;
  flex: 1;
  gap: 16px;
}
.transcript-col-label {
  flex: 1;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
}
.transcript-col-label.label-edit { text-align: left; }

.transcript-columns {
  display: flex;
  gap: 16px;
  align-items: stretch;
}

.script-page {
  flex: 1;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  max-height: 55vh;
  overflow-y: auto;
}
.script-page.pane-original {
  border-left: 3px solid var(--border);
}
.script-page.pane-edit {
  border-left: 3px solid var(--blue);
}

/* Block cards */
.block-card {
  padding: 14px 20px;
  border-bottom: 1px solid var(--border-light);
  transition: background 0.15s;
  position: relative;
  animation: fadeSlideIn 0.3s ease-out both;
}
@keyframes fadeSlideIn {
  from { opacity: 0; transform: translateY(4px); }
  to { opacity: 1; transform: translateY(0); }
}
.block-card:last-child { border-bottom: none; }
.block-card:hover { background: var(--bg-page); }
.block-card.active {
  background: var(--blue-pale);
  box-shadow: inset 3px 0 0 var(--blue);
}

.block-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}
.block-meta-left {
  display: flex;
  align-items: center;
  gap: 10px;
}
.block-number {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 500;
  color: var(--text-dim);
  background: var(--bg-page);
  padding: 2px 8px;
  border-radius: 4px;
  min-width: 28px;
  text-align: center;
}
.block-time {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-dim);
  cursor: pointer;
}
.block-time:hover { color: var(--blue); }
.block-actions {
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0;
  transition: opacity 0.15s;
}
.block-card:hover .block-actions { opacity: 1; }

.block-text {
  font-family: var(--font-script);
  font-size: 14px;
  line-height: 1.65;
  color: var(--text);
  min-height: 1.65em;
  outline: none;
  padding: 2px 0;
  border-bottom: 1px solid transparent;
  transition: border-color 0.15s;
}
.block-text:focus {
  border-bottom-color: var(--blue);
}
.block-text[contenteditable="true"]::selection {
  background: var(--blue-light);
}

/* ── Cut blocks (edit pane) ── */
.pane-edit .block-card.is-cut {
  background: var(--brick-light);
  opacity: 0.7;
}
.pane-edit .block-card.is-cut .block-number { background: var(--brick-light); color: var(--brick); }
.pane-edit .block-card.is-cut .block-text {
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  color: var(--text-dim);
  font-style: italic;
}
.pane-edit .block-card.is-cut .block-actions { opacity: 1; }

/* ── Cut blocks (original pane) ── */
.pane-original .block-card.is-cut {
  background: var(--brick-light);
}
.pane-original .block-card.is-cut .block-number { background: var(--brick-light); color: var(--brick); }
.pane-original .block-card.is-cut .block-text {
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  color: var(--brick);
}

/* ── Word-level diff marks (original pane) ── */
.diff-del {
  color: var(--brick);
  background: var(--brick-light);
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  border-radius: 2px;
  padding: 0 2px;
}
.diff-ok {
  /* default — no special styling */
}

/* ── Cut badge ── */
.cut-badge {
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--brick);
  background: var(--bg-surface);
  border: 1px solid var(--brick);
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ── Edited badge ── */
.edited-badge {
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--sunray);
  background: var(--sunray-light);
  border: 1px solid var(--sunray);
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ── Export Section ── */
#export-section {
  padding: 24px 0;
}
.export-bar {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
  box-shadow: var(--shadow-sm);
}
.export-field {
  display: flex;
  align-items: center;
  gap: 8px;
}
.export-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.export-bar select,
.export-bar input[type="range"] {
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  font-family: var(--font-display);
  padding: 6px 10px;
  background: var(--bg-surface);
  color: var(--text);
}
.export-bar input[type="range"] { width: 120px; accent-color: var(--blue); }
.range-val {
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--blue);
  min-width: 40px;
}
.export-spacer { flex: 1; }

/* ── Info Tooltip ── */
.info-tip {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--border);
  color: var(--text-dim);
  font-size: 10px;
  font-weight: 700;
  font-style: normal;
  font-family: var(--font-display);
  cursor: pointer;
  position: relative;
  margin-left: 4px;
  vertical-align: middle;
  flex-shrink: 0;
  transition: background 0.15s, color 0.15s;
}
.info-tip:hover {
  background: var(--blue);
  color: #fff;
}
.info-tip .tip-text {
  display: none;
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--ink);
  color: #e0e0e0;
  font-size: 12px;
  font-weight: 400;
  line-height: 1.5;
  padding: 10px 14px;
  border-radius: 6px;
  width: 260px;
  white-space: normal;
  box-shadow: var(--shadow-lg);
  z-index: 100;
  pointer-events: none;
}
.info-tip .tip-text::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--ink);
}
.info-tip:hover .tip-text,
.info-tip:focus .tip-text {
  display: block;
}

/* ── Advanced Panel ── */
#advanced-panel {
  padding-bottom: 24px;
}
.advanced-card {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 24px;
  box-shadow: var(--shadow-sm);
}
.advanced-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
}
.advanced-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 14px;
}
.advanced-grid label {
  display: flex;
  flex-direction: column;
  gap: 5px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}
.advanced-grid label > span {
  display: inline-flex;
  align-items: center;
}
.advanced-grid input {
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text);
  background: var(--bg-surface);
  transition: border-color 0.15s;
}
.advanced-grid input:focus { outline: none; border-color: var(--blue); }

/* ── Export Result ── */
#export-result {
  margin-bottom: 24px;
  padding: 16px 20px;
  border-radius: var(--radius);
  font-family: var(--font-mono);
  font-size: 12px;
  white-space: pre-wrap;
  line-height: 1.6;
}
#export-result.success {
  background: var(--green-light);
  color: #2d6e3f;
  border: 1px solid var(--green);
}
#export-result.error {
  background: var(--brick-light);
  color: var(--brick);
  border: 1px solid var(--brick);
}

/* ── Scrollbar ── */
.script-page::-webkit-scrollbar { width: 6px; }
.script-page::-webkit-scrollbar-track { background: transparent; }
.script-page::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.script-page::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

/* ── Stagger delays ── */
.script-page .block-card:nth-child(1) { animation-delay: 0.02s; }
.script-page .block-card:nth-child(2) { animation-delay: 0.04s; }
.script-page .block-card:nth-child(3) { animation-delay: 0.06s; }
.script-page .block-card:nth-child(4) { animation-delay: 0.08s; }
.script-page .block-card:nth-child(5) { animation-delay: 0.10s; }
.script-page .block-card:nth-child(6) { animation-delay: 0.12s; }
.script-page .block-card:nth-child(7) { animation-delay: 0.14s; }
.script-page .block-card:nth-child(8) { animation-delay: 0.16s; }
.script-page .block-card:nth-child(9) { animation-delay: 0.18s; }
.script-page .block-card:nth-child(n+10) { animation-delay: 0.20s; }

/* ── Theme Toggle ── */
.theme-toggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  width: 34px;
  height: 34px;
  border-radius: 6px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  transition: all 0.15s;
  line-height: 1;
}
.theme-toggle:hover {
  border-color: var(--blue);
  color: var(--blue);
}
.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ── Search Bar ── */
.search-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: var(--bg-surface);
  border: 1px solid var(--blue);
  border-radius: var(--radius);
  margin-bottom: 10px;
  box-shadow: var(--shadow-sm);
}
.search-bar input {
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 10px;
  font-family: var(--font-display);
  font-size: 13px;
  flex: 1;
  min-width: 180px;
  color: var(--text);
  background: var(--bg-surface);
}
.search-bar input:focus { outline: none; border-color: var(--blue); }
.search-bar .search-count {
  font-size: 12px;
  color: var(--text-dim);
  font-family: var(--font-mono);
  white-space: nowrap;
}
mark.search-highlight {
  background: var(--sunray-light);
  color: var(--text);
  border-radius: 2px;
  padding: 0 1px;
}
mark.search-highlight.current {
  background: var(--sunray);
  color: #000;
}

/* ── Keyboard Nav & Multi-Select ── */
.block-card.focused {
  outline: 2px solid var(--blue);
  outline-offset: -2px;
}
.block-card.selected {
  background: var(--blue-pale) !important;
}

</style>
</head>
<body>

<header>
  <div class="container-wide">
    <h1>Paper<span>Cut</span></h1>
    <div class="header-actions">
      <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle dark mode"></button>
      <button id="settingsToggle" onclick="toggleSettings()">Settings</button>
    </div>
  </div>
</header>

<!-- Settings Overlay -->
<div id="settingsOverlay" class="settings-overlay hidden" onclick="if(event.target===this)toggleSettings()">
  <div class="settings-panel">
    <div class="settings-header">
      <h2>Settings</h2>
      <button class="settings-close" onclick="toggleSettings()">&times;</button>
    </div>
    <div class="settings-body">

      <div class="settings-section">
        <div class="settings-section-title">Transcription</div>
        <div class="settings-grid">
          <div class="settings-field full-width">
            <label>Transcription engine</label>
            <select id="settTranscriptionEngine" onchange="updateEngineFields()">
              <option value="whisperx">WhisperX</option>
              <option value="crisperwhisper">CrisperWhisper (verbatim)</option>
            </select>
            <span class="hint">CrisperWhisper preserves filler words (um, uh), stutters, and false starts</span>
          </div>
          <div class="settings-field" id="settWhisperModelField">
            <label>WhisperX model</label>
            <select id="settWhisperModel">
              <option value="tiny">tiny</option>
              <option value="base">base</option>
              <option value="small">small</option>
              <option value="medium" selected>medium</option>
              <option value="large-v2">large-v2</option>
              <option value="large-v3">large-v3</option>
            </select>
          </div>
          <div class="settings-field">
            <label>Language</label>
            <input type="text" id="settLanguage" value="en" placeholder="en">
            <span class="hint">ISO 639-1 code (en, es, fr, de, ja...)</span>
          </div>
        </div>
      </div>

      <div class="settings-section">
        <div class="settings-section-title">Export Defaults</div>
        <div class="settings-grid">
          <div class="settings-field">
            <label>Default format</label>
            <select id="settExportFormat">
              <option value="final-cut-pro">Final Cut Pro</option>
              <option value="premiere">Premiere</option>
              <option value="resolve">DaVinci Resolve</option>
              <option value="clip-sequence">Clip Sequence</option>
              <option value="video" id="settExportFormatVideoOpt">Video</option>
            </select>
          </div>
          <div class="settings-field">
            <label>Default margin (sec)</label>
            <input type="number" id="settMargin" value="0.10" min="0" max="2" step="0.05">
          </div>
          <div class="settings-field">
            <label>Silent speed</label>
            <input type="text" id="settSilentSpeed" placeholder="99999 (cut)">
          </div>
          <div class="settings-field">
            <label>Sounded speed</label>
            <input type="text" id="settSoundedSpeed" placeholder="1">
          </div>
          <div class="settings-field" id="settVideoCodecField">
            <label>Video codec</label>
            <input type="text" id="settVideoCodec" placeholder="auto">
          </div>
          <div class="settings-field">
            <label>Audio codec</label>
            <input type="text" id="settAudioCodec" placeholder="auto">
          </div>
          <div class="settings-field full-width">
            <label>FFmpeg args</label>
            <input type="text" id="settFfmpegArgs" placeholder="-crf 22 -preset veryfast">
          </div>
          <div class="settings-field full-width">
            <label>Edit method</label>
            <input type="text" id="settEditMethod" placeholder="audio:threshold=4%">
            <span class="hint">auto-editor --edit flag (e.g. audio:threshold=4%, motion:threshold=2%)</span>
          </div>
          <div class="settings-field full-width">
            <label>Export folder</label>
            <input type="text" id="settExportFolder" placeholder="Same folder as video">
            <span class="hint">Where exported files are saved. Leave blank to save next to the source video.</span>
          </div>
        </div>
      </div>

      <div class="settings-section">
        <div class="settings-section-title">Editor</div>
        <div class="settings-grid">
          <div class="settings-field">
            <label>Sync playback on load</label>
            <select id="settSyncPlayback">
              <option value="true" selected>On</option>
              <option value="false">Off</option>
            </select>
          </div>
          <div class="settings-field">
            <label>Sync scroll on load</label>
            <select id="settSyncScroll">
              <option value="true" selected>On</option>
              <option value="false">Off</option>
            </select>
          </div>
        </div>
      </div>

    </div>
    <div class="settings-footer">
      <button class="btn btn-secondary btn-sm" onclick="resetSettings()">Reset Defaults</button>
      <button class="btn btn-primary btn-sm" onclick="saveSettings()">Save</button>
    </div>
  </div>
</div>

<div class="container">

  <!-- Drop Zone -->
  <div class="drop-zone-wrap">
    <div class="drop-zone" id="dropZone">
      <div class="drop-zone-icon">&#127916;</div>
      <div class="drop-zone-text">Drop a video or audio file here or <strong>click to browse</strong></div>
      <div class="drop-zone-hint">mp4, mov, mkv, webm, mp3, wav, m4a, flac</div>
      <input type="file" class="drop-zone-file-input" id="fileInput" accept="video/*,audio/*">
    </div>
    <div class="drop-alt">
      <span class="drop-alt-divider">or</span>
      <input type="text" class="path-input" id="videoPath" placeholder="paste a local path" spellcheck="false">
      <button class="btn btn-secondary btn-sm" id="loadExistingBtn" onclick="loadExisting()">Load Existing</button>
    </div>
  </div>

  <!-- Progress log -->
  <div class="hidden" id="progress-section">
    <div id="progress-log"></div>
  </div>

  <!-- Video player -->
  <div class="hidden" id="video-section">
    <div class="video-wrap">
      <video id="videoPlayer" controls preload="metadata"></video>
    </div>
    <div class="video-toolbar">
      <label><input type="checkbox" id="syncToggle" checked> Sync playback</label>
      <label><input type="checkbox" id="scrollSyncToggle" checked> Sync scroll</label>
    </div>
  </div>

  <!-- Stats bar -->
  <div id="summary-bar" class="hidden">
    <div class="stat-card">
      <div class="stat-label">Blocks</div>
      <div class="stat-val" id="sumTotal">0</div>
    </div>
    <div class="stat-card stat-danger">
      <div class="stat-label">Cut</div>
      <div class="stat-val" id="sumRemoved">0</div>
    </div>
    <div class="stat-card stat-accent">
      <div class="stat-label">Time Removed</div>
      <div class="stat-val" id="sumTimeCut">0.0s</div>
    </div>
    <div class="stat-card stat-accent">
      <div class="stat-label">Reduction</div>
      <div class="stat-val" id="sumReduction">0%</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Est. Output</div>
      <div class="stat-val" id="sumEstOutput">0.0s</div>
    </div>
  </div>

</div><!-- /.container -->

<!-- Transcript uses wider container for two columns -->
<div class="container-wide">

  <div id="transcript-section" class="hidden">
    <div class="transcript-header">
      <div class="transcript-col-headers">
        <div class="transcript-col-label">Original</div>
        <div class="transcript-col-label label-edit">Edit</div>
      </div>
      <div style="display:flex;align-items:center;gap:6px;">
        <button class="btn btn-secondary btn-sm" onclick="cleanFillers()">Clean Fillers</button>
        <button class="btn btn-secondary btn-sm" onclick="dedupeTakes()">Dedupe Takes</button>
        <button class="btn btn-danger-outline btn-sm" onclick="clearAllCuts()">Clear All Cuts</button>
        <span style="width:1px;height:18px;background:var(--border);margin:0 4px;"></span>
        <button class="btn btn-secondary btn-sm" id="undoBtn" onclick="undoLast()" disabled>Undo</button>
        <button class="btn btn-secondary btn-sm" id="redoBtn" onclick="redoLast()" disabled>Redo</button>
        <span id="autosaveIndicator" style="font-size:11px;color:var(--green);opacity:0;transition:opacity 0.3s;margin-left:6px;">Saved</span>
      </div>
    </div>
    <div class="transcript-columns">
      <div class="script-page pane-original" id="originalPane"></div>
      <div class="script-page pane-edit" id="editPane"></div>
    </div>
  </div>

  <!-- Export controls -->
  <div class="hidden" id="export-section">
    <div class="export-bar">
      <div class="export-field">
        <span class="export-label">Margin</span>
        <input type="range" id="marginSlider" min="0" max="1" step="0.05" value="0.10">
        <span class="range-val" id="marginVal">0.10s</span>
      </div>
      <div class="export-field">
        <span class="export-label">Format</span>
        <select id="exportFormat">
          <option value="final-cut-pro">Final Cut Pro</option>
          <option value="premiere">Premiere</option>
          <option value="resolve">DaVinci Resolve</option>
          <option value="clip-sequence">Clip Sequence</option>
          <option value="video" id="exportFormatVideoOpt">Video</option>
        </select>
      </div>
      <div class="export-spacer"></div>
      <button class="btn btn-secondary btn-sm" id="advancedToggle" onclick="toggleAdvanced()">Advanced</button>
      <button class="btn btn-primary" id="exportBtn" onclick="startExport()">Export</button>
    </div>
  </div>

  <!-- Advanced panel -->
  <div id="advanced-panel" class="hidden">
    <div class="advanced-card">
      <div class="advanced-title">Advanced Options</div>
      <div class="advanced-grid">
        <label><span>Silent speed <span class="info-tip" tabindex="0">i<span class="tip-text">Playback speed for silent/cut sections. Use 99999 to fully remove them, or a number like 8 to speed them up instead.</span></span></span> <input type="text" id="silentSpeed" placeholder="99999 (cut)"></label>
        <label><span>Sounded speed <span class="info-tip" tabindex="0">i<span class="tip-text">Playback speed for sections with audio. Default is 1 (normal speed). Use 1.5 or 2 to speed up the entire sounded portion.</span></span></span> <input type="text" id="soundedSpeed" placeholder="1"></label>
        <label id="videoCodecField"><span>Video codec <span class="info-tip" tabindex="0">i<span class="tip-text">Video codec for re-encoding. Common options: h264, h265/hevc, prores. Leave blank for auto-editor's default.</span></span></span> <input type="text" id="videoCodec" placeholder="auto"></label>
        <label><span>Audio codec <span class="info-tip" tabindex="0">i<span class="tip-text">Audio codec for re-encoding. Common options: aac, pcm_s16le, mp3. Leave blank for auto-editor's default.</span></span></span> <input type="text" id="audioCodec" placeholder="auto"></label>
        <label><span>FFmpeg args <span class="info-tip" tabindex="0">i<span class="tip-text">Extra FFmpeg arguments passed through to the encoder. Example: -crf 22 -preset veryfast for H.264 quality/speed tradeoff.</span></span></span> <input type="text" id="ffmpegArgs" placeholder="-crf 22 -preset veryfast"></label>
        <label><span>Edit method <span class="info-tip" tabindex="0">i<span class="tip-text">auto-editor's --edit flag. Controls what gets detected as silence. Examples: audio:threshold=4%, motion:threshold=2%, or combine with audio:or:motion.</span></span></span> <input type="text" id="editMethod" placeholder="audio:threshold=4%"></label>
      </div>
      <div style="display:flex;align-items:center;gap:10px;margin-top:16px;padding-top:14px;border-top:1px solid var(--border-light);">
        <span style="font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:1.2px;color:var(--text-dim);">Preset</span>
        <select id="presetSelect" onchange="loadPreset()" style="min-width:140px;border:1px solid var(--border);border-radius:6px;padding:6px 10px;font-size:13px;font-family:var(--font-display);background:var(--bg-surface);color:var(--text);">
          <option value="">— None —</option>
        </select>
        <button class="btn btn-secondary btn-sm" onclick="savePreset()">Save Preset</button>
        <button class="btn btn-danger-outline btn-sm" onclick="deletePreset()">Delete</button>
      </div>
    </div>
  </div>

  <!-- Export result -->
  <div id="export-result" class="hidden"></div>

</div><!-- /.container-wide -->

<script>
// ── State ──
let blocks = [];       // {id, index, start, end, text, originalText, deleted}
let undoStack = [];    // [{type: 'cut'|'edit'|'restore', id, prevText?}]
let redoStack = [];
let videoPath = "";
let srtPath = "";
let origSrtPath = "";
let jsonPath = "";
let currentHighlight = -1;
let deletedRanges = [];
let scrollSyncing = false;
let isAudioFile = false;
const AUDIO_EXTENSIONS = new Set(['mp3','wav','m4a','flac','ogg','aac','wma']);
function checkIsAudio(path) {
  const ext = path.split('.').pop().toLowerCase();
  return AUDIO_EXTENSIONS.has(ext);
}

// Keyboard nav & multi-select state
let focusedBlockId = null;
let selectedBlocks = new Set();
let lastClickedBlockId = null;

// Search state
let searchOpen = false;
let searchMatches = []; // [{blockId, markEl}]
let currentMatchIndex = -1;

// ── DOM refs ──
const $dropZone = document.getElementById("dropZone");
const $fileInput = document.getElementById("fileInput");
const $videoPathInput = document.getElementById("videoPath");
const $progressSection = document.getElementById("progress-section");
const $progressLog = document.getElementById("progress-log");
const $videoSection = document.getElementById("video-section");
const $videoPlayer = document.getElementById("videoPlayer");
const $syncToggle = document.getElementById("syncToggle");
const $scrollSyncToggle = document.getElementById("scrollSyncToggle");
const $transcriptSection = document.getElementById("transcript-section");
const $originalPane = document.getElementById("originalPane");
const $editPane = document.getElementById("editPane");
const $exportSection = document.getElementById("export-section");
const $marginSlider = document.getElementById("marginSlider");
const $marginVal = document.getElementById("marginVal");
const $undoBtn = document.getElementById("undoBtn");
const $redoBtn = document.getElementById("redoBtn");
const $summaryBar = document.getElementById("summary-bar");
const $exportResult = document.getElementById("export-result");
const $autosaveIndicator = document.getElementById("autosaveIndicator");

// ── Utilities ──
let _debounceTimers = {};
function debounce(key, fn, ms = 250) {
  clearTimeout(_debounceTimers[key]);
  _debounceTimers[key] = setTimeout(fn, ms);
}

function fmt(sec) {
  const m = Math.floor(sec / 60);
  const s = (sec % 60).toFixed(1);
  return m > 0 ? `${m}:${s.padStart(4, '0')}` : `${s}s`;
}

function logLine(msg, cls = "") {
  const div = document.createElement("div");
  div.className = "line" + (cls ? ` line-${cls}` : "");
  div.textContent = msg;
  $progressLog.appendChild(div);
  $progressLog.scrollTop = $progressLog.scrollHeight;
}

function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Word-Level Diff ──
// Uses LCS to find which words from the original were deleted
function wordDiff(original, edited) {
  const a = original.split(/(\s+)/).filter(s => s.length > 0);
  const b = edited.split(/(\s+)/).filter(s => s.length > 0);

  // Extract just the words (non-whitespace) for comparison
  const aWords = a.filter(s => s.trim().length > 0);
  const bWords = b.filter(s => s.trim().length > 0);

  const m = aWords.length, n = bWords.length;

  // Build LCS table
  const dp = [];
  for (let i = 0; i <= m; i++) {
    dp[i] = new Array(n + 1).fill(0);
  }
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (aWords[i - 1] === bWords[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  // Backtrack to find which original words are kept vs deleted
  const result = []; // {word, deleted: bool}
  let i = m, j = n;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && aWords[i - 1] === bWords[j - 1]) {
      result.unshift({ word: aWords[i - 1], deleted: false });
      i--; j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      // Word added in edited — skip (not shown on left)
      j--;
    } else {
      result.unshift({ word: aWords[i - 1], deleted: true });
      i--;
    }
  }
  return result;
}

function renderDiffHtml(original, edited) {
  if (original === edited) return escHtml(original);

  const diff = wordDiff(original, edited);
  return diff.map(({ word, deleted }) =>
    deleted
      ? `<span class="diff-del">${escHtml(word)}</span>`
      : escHtml(word)
  ).join(" ");
}

// ── Drag & Drop ──
$dropZone.addEventListener("click", () => $fileInput.click());
$fileInput.addEventListener("change", (e) => {
  if (e.target.files.length) uploadFile(e.target.files[0]);
});

$dropZone.addEventListener("dragover", (e) => {
  e.preventDefault();
  $dropZone.classList.add("dragover");
});
$dropZone.addEventListener("dragleave", () => {
  $dropZone.classList.remove("dragover");
});
$dropZone.addEventListener("drop", (e) => {
  e.preventDefault();
  $dropZone.classList.remove("dragover");
  const file = e.dataTransfer.files[0];
  if (file) uploadFile(file);
});

function uploadFile(file) {
  $dropZone.classList.add("uploading");
  $dropZone.querySelector(".drop-zone-text").textContent = `Uploading ${file.name}...`;

  const form = new FormData();
  form.append("file", file);

  fetch("/api/upload", { method: "POST", body: form })
    .then(r => {
      if (!r.ok) return r.text().then(t => { throw new Error(`Upload failed (${r.status}): ${t.slice(0, 100)}`); });
      return r.json();
    })
    .then(data => {
      if (data.error) throw new Error(data.error);
      videoPath = data.path;
      $videoPathInput.value = videoPath;
      $dropZone.querySelector(".drop-zone-text").innerHTML = `<strong>${data.filename}</strong> ready`;
      $dropZone.classList.remove("uploading");
      startTranscribe();
    })
    .catch(err => {
      $dropZone.querySelector(".drop-zone-text").textContent = "Upload failed: " + err.message;
      $dropZone.classList.remove("uploading");
    });
}

// ── Transcription ──
function startTranscribe() {
  const path = videoPath || $videoPathInput.value.trim();
  if (!path) return;
  videoPath = path;
  isAudioFile = checkIsAudio(videoPath);

  $progressSection.classList.remove("hidden");
  $progressLog.innerHTML = "";

  fetch("/api/transcribe", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      video_path: path,
      model: loadSettings().whisperModel,
      language: loadSettings().language,
      engine: loadSettings().transcriptionEngine,
    }),
  }).then(response => {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    function read() {
      reader.read().then(({ done, value }) => {
        if (done) return;
        buf += decoder.decode(value, { stream: true });
        const lines = buf.split("\n");
        buf = lines.pop();
        for (const line of lines) {
          if (!line.startsWith("data: ")) continue;
          try {
            const evt = JSON.parse(line.slice(6));
            if (evt.type === "progress") logLine(evt.message);
            else if (evt.type === "start") logLine(evt.message);
            else if (evt.type === "error") logLine(evt.message, "error");
            else if (evt.type === "done") {
              logLine(evt.message, "done");
              srtPath = evt.srt_path;
              origSrtPath = evt.orig_srt_path;
              jsonPath = evt.json_path;
              loadTranscript();
            }
          } catch (_) {}
        }
        read();
      });
    }
    read();
  }).catch(err => {
    logLine("Request failed: " + err.message, "error");
  });
}

// ── Load Existing ──
function loadExisting() {
  const path = $videoPathInput.value.trim();
  if (!path) return;
  videoPath = path;
  isAudioFile = checkIsAudio(videoPath);

  const base = path.replace(/\.[^.]+$/, "");
  srtPath = base + ".srt";
  origSrtPath = base + ".srt.orig";
  jsonPath = base + ".json";
  loadTranscript();
}

// ── Load Transcript ──
function updateMediaTypeUI() {
  $videoSection.classList.toggle("audio-only", isAudioFile);
  document.getElementById("videoCodecField").style.display = isAudioFile ? "none" : "";
  document.getElementById("settVideoCodecField").style.display = isAudioFile ? "none" : "";
  const label = isAudioFile ? "Audio" : "Video";
  document.getElementById("exportFormatVideoOpt").textContent = label;
  document.getElementById("settExportFormatVideoOpt").textContent = label;
}

function loadTranscript() {
  $videoPlayer.src = `/media?path=${encodeURIComponent(videoPath)}`;
  $videoSection.classList.remove("hidden");
  updateMediaTypeUI();

  // Try .srt.orig first, then .srt
  fetch(`/api/srt?path=${encodeURIComponent(origSrtPath)}`)
    .then(r => {
      if (r.ok) return r.json();
      return fetch(`/api/srt?path=${encodeURIComponent(srtPath)}`).then(r2 => {
        if (r2.ok) return r2.json();
        return null; // No SRT found
      });
    })
    .then(data => {
      if (!data || data.error || !Array.isArray(data)) {
        // No transcript exists yet — offer to transcribe
        $progressSection.classList.remove("hidden");
        logLine("No transcript found. Starting transcription...", "");
        startTranscribe();
        return;
      }

      blocks = data.map((b, i) => ({
        id: i,
        index: b.index,
        start: b.start,
        end: b.end,
        text: b.text,
        originalText: b.text,
        deleted: false,
      }));
      undoStack = [];
      redoStack = [];
      $undoBtn.disabled = true;
      $redoBtn.disabled = true;
      focusedBlockId = null;
      selectedBlocks.clear();

      // Check for autosave before rendering
      checkAutosave();

      renderTranscript();
      $transcriptSection.classList.remove("hidden");
      $exportSection.classList.remove("hidden");
      $summaryBar.classList.remove("hidden");
      updateSummary();
    })
    .catch(err => {
      $progressSection.classList.remove("hidden");
      logLine("Failed to load SRT: " + err.message, "error");
    });
}

// ── Render Both Panes ──
function renderTranscript() {
  renderOriginalPane();
  renderEditPane();
  bindEditPaneEvents();
  bindScrollSync();
}

function renderOriginalPane() {
  $originalPane.innerHTML = "";

  for (const b of blocks) {
    const card = document.createElement("div");
    card.className = "block-card" + (b.deleted ? " is-cut" : "");
    card.dataset.id = b.id;
    card.dataset.start = b.start;
    card.dataset.end = b.end;

    const isEdited = !b.deleted && b.text !== b.originalText;
    const badgeHtml = b.deleted
      ? `<span class="cut-badge">\u2702 CUT</span>`
      : (isEdited ? `<span class="edited-badge">\u270E Edited</span>` : "");

    const textHtml = b.deleted
      ? escHtml(b.originalText)
      : renderDiffHtml(b.originalText, b.text);

    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          ${badgeHtml}
        </div>
      </div>
      <div class="block-text">${textHtml}</div>
    `;

    card.addEventListener("click", () => seekTo(b.start));
    $originalPane.appendChild(card);
  }
}

function renderEditPane() {
  $editPane.innerHTML = "";

  for (const b of blocks) {
    const card = document.createElement("div");
    let cls = "block-card";
    if (b.deleted) cls += " is-cut";
    if (b.id === focusedBlockId) cls += " focused";
    if (selectedBlocks.has(b.id)) cls += " selected";
    card.className = cls;
    card.dataset.id = b.id;
    card.dataset.start = b.start;
    card.dataset.end = b.end;

    if (b.deleted) {
      card.innerHTML = `
        <div class="block-meta">
          <div class="block-meta-left">
            <span class="block-number">${b.index ?? b.id + 1}</span>
            <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
            <span class="cut-badge">\u2702 CUT</span>
          </div>
          <div class="block-actions" style="opacity:1">
            <button class="btn btn-success-outline btn-sm" data-restore="${b.id}">Restore</button>
          </div>
        </div>
        <div class="block-text">${escHtml(b.originalText)}</div>
      `;
    } else {
      card.innerHTML = `
        <div class="block-meta">
          <div class="block-meta-left">
            <span class="block-number">${b.index ?? b.id + 1}</span>
            <span class="block-time" data-seek="${b.start}">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          </div>
          <div class="block-actions">
            <button class="btn btn-danger-outline btn-sm" data-cut="${b.id}">Cut</button>
          </div>
        </div>
        <div class="block-text" contenteditable="true" data-block-id="${b.id}">${escHtml(b.text)}</div>
      `;
    }

    $editPane.appendChild(card);
  }
}

function bindTextEditing(el) {
  if (!el) return;
  const id = parseInt(el.dataset.blockId);

  // Track text at focus time for undo
  let textAtFocus = "";
  el.addEventListener("focus", () => {
    const b = blocks.find(x => x.id === id);
    if (b) textAtFocus = b.text;
  });

  // Live update on input (debounced)
  el.addEventListener("input", () => {
    const b = blocks.find(x => x.id === id);
    if (!b) return;
    b.text = el.textContent.trim();
    debounce("edit-" + id, () => {
      updateOriginalBlock(id);
      updateSummary();
    }, 150);
  });

  // Snapshot undo on blur
  el.addEventListener("blur", () => {
    const b = blocks.find(x => x.id === id);
    if (!b) return;
    b.text = el.textContent.trim();
    if (b.text !== textAtFocus) {
      undoStack.push({ type: "edit", id: b.id, prevText: textAtFocus });
      redoStack = [];
      $undoBtn.disabled = false;
      $redoBtn.disabled = true;
      triggerAutosave();
    }
    // Final sync (no debounce)
    updateOriginalBlock(id);
    updateSummary();
  });

  el.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); el.blur(); }
  });
}

function bindEditPaneEvents() {
  // Cut buttons
  $editPane.querySelectorAll("[data-cut]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      cutBlock(parseInt(btn.dataset.cut));
    });
  });

  // Restore buttons
  $editPane.querySelectorAll("[data-restore]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const id = parseInt(btn.dataset.restore);
      restoreBlock(id);
      undoStack.push({ type: "restore", id });
      redoStack = [];
      $undoBtn.disabled = false;
      $redoBtn.disabled = true;
    });
  });

  // Seek on timestamp click
  $editPane.querySelectorAll("[data-seek]").forEach(el => {
    el.addEventListener("click", () => seekTo(parseFloat(el.dataset.seek)));
  });

  // Text editing — live sync to left on input, undo snapshot on blur
  $editPane.querySelectorAll('.block-text[contenteditable="true"]').forEach(el => {
    bindTextEditing(el);
  });

  // Click card: focus/select + seek (but not on buttons or editable text)
  $editPane.querySelectorAll(".block-card").forEach(card => {
    card.addEventListener("click", (e) => {
      if (e.target.closest("button") || e.target.closest('[contenteditable="true"]')) return;
      const id = parseInt(card.dataset.id);

      if (e.shiftKey && lastClickedBlockId !== null) {
        selectRange(lastClickedBlockId, id);
      } else {
        selectedBlocks.clear();
        setFocus(id);
        lastClickedBlockId = id;
      }
      seekTo(parseFloat(card.dataset.start));
    });
  });
}

// ── Update single block on original pane (after text edit) ──
function updateOriginalBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b) return;

  const card = $originalPane.querySelector(`[data-id="${id}"]`);
  if (!card) return;

  const isEdited = !b.deleted && b.text !== b.originalText;
  const badgeHtml = b.deleted
    ? `<span class="cut-badge">\u2702 CUT</span>`
    : (isEdited ? `<span class="edited-badge">\u270E Edited</span>` : "");

  const textHtml = b.deleted
    ? escHtml(b.originalText)
    : renderDiffHtml(b.originalText, b.text);

  card.className = "block-card" + (b.deleted ? " is-cut" : "");
  card.innerHTML = `
    <div class="block-meta">
      <div class="block-meta-left">
        <span class="block-number">${b.index ?? b.id + 1}</span>
        <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
        ${badgeHtml}
      </div>
    </div>
    <div class="block-text">${textHtml}</div>
  `;
  card.addEventListener("click", () => seekTo(b.start));
}

// ── Update single block on edit pane ──
function updateEditBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b) return;

  const card = $editPane.querySelector(`[data-id="${id}"]`);
  if (!card) return;

  card.className = "block-card" + (b.deleted ? " is-cut" : "");

  if (b.deleted) {
    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          <span class="cut-badge">\u2702 CUT</span>
        </div>
        <div class="block-actions" style="opacity:1">
          <button class="btn btn-success-outline btn-sm" data-restore="${b.id}">Restore</button>
        </div>
      </div>
      <div class="block-text">${escHtml(b.originalText)}</div>
    `;
    card.querySelector("[data-restore]").addEventListener("click", (e) => {
      e.stopPropagation();
      restoreBlock(b.id);
      undoStack.push({ type: "restore", id: b.id });
      redoStack = [];
      $undoBtn.disabled = false;
      $redoBtn.disabled = true;
    });
  } else {
    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time" data-seek="${b.start}">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
        </div>
        <div class="block-actions">
          <button class="btn btn-danger-outline btn-sm" data-cut="${b.id}">Cut</button>
        </div>
      </div>
      <div class="block-text" contenteditable="true" data-block-id="${b.id}">${escHtml(b.text)}</div>
    `;
    card.querySelector("[data-cut]").addEventListener("click", (e) => {
      e.stopPropagation();
      cutBlock(b.id);
    });
    card.querySelector("[data-seek]").addEventListener("click", () => seekTo(b.start));
    bindTextEditing(card.querySelector('[contenteditable="true"]'));
  }

  card.addEventListener("click", (e) => {
    if (e.target.closest("button") || e.target.closest('[contenteditable="true"]')) return;
    seekTo(parseFloat(card.dataset.start));
  });
}

// ── Scroll Sync ──
function bindScrollSync() {
  let scrollSource = null; // which pane initiated the sync
  let scrollTimer = null;

  function syncScroll(source, target) {
    // If the other pane started the sync, ignore this event
    if (scrollSource && scrollSource !== source) return;
    scrollSource = source;

    const pct = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
    target.scrollTop = pct * (target.scrollHeight - target.clientHeight);

    // Release the lock after scrolling settles
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => { scrollSource = null; }, 100);
  }

  $originalPane.addEventListener("scroll", () => {
    if ($scrollSyncToggle.checked) syncScroll($originalPane, $editPane);
  });
  $editPane.addEventListener("scroll", () => {
    if ($scrollSyncToggle.checked) syncScroll($editPane, $originalPane);
  });
}

// ── Cut / Restore ──
function cutBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b || b.deleted) return;
  b.deleted = true;
  undoStack.push({ type: "cut", id: b.id });
  redoStack = [];
  $undoBtn.disabled = false;
  $redoBtn.disabled = true;

  updateEditBlock(id);
  updateOriginalBlock(id);
  updateSummary();
  triggerAutosave();
  if (searchOpen) performSearch();
}

function restoreBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b || !b.deleted) return;
  b.deleted = false;

  updateEditBlock(id);
  updateOriginalBlock(id);
  updateSummary();
  triggerAutosave();
  if (searchOpen) performSearch();
}

function undoLast() {
  if (!undoStack.length) return;
  const action = undoStack.pop();
  $undoBtn.disabled = undoStack.length === 0;

  if (action.type === "cut") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      b.deleted = false;
      redoStack.push({ type: "cut", id: action.id });
      $redoBtn.disabled = false;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  } else if (action.type === "restore") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      b.deleted = true;
      redoStack.push({ type: "restore", id: action.id });
      $redoBtn.disabled = false;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  } else if (action.type === "edit") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      const currentText = b.text;
      b.text = action.prevText;
      redoStack.push({ type: "edit", id: action.id, prevText: currentText });
      $redoBtn.disabled = false;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  }
  triggerAutosave();
  if (searchOpen) performSearch();
}

function redoLast() {
  if (!redoStack.length) return;
  const action = redoStack.pop();
  $redoBtn.disabled = redoStack.length === 0;

  if (action.type === "cut") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      b.deleted = true;
      undoStack.push({ type: "cut", id: action.id });
      $undoBtn.disabled = false;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  } else if (action.type === "restore") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      b.deleted = false;
      undoStack.push({ type: "restore", id: action.id });
      $undoBtn.disabled = false;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  } else if (action.type === "edit") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      const currentText = b.text;
      b.text = action.prevText;
      undoStack.push({ type: "edit", id: action.id, prevText: currentText });
      $undoBtn.disabled = false;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  }
  triggerAutosave();
  if (searchOpen) performSearch();
}

// ── Summary ──
function updateSummary() {
  const total = blocks.length;
  const removed = blocks.filter(b => b.deleted).length;
  const edited = blocks.filter(b => !b.deleted && b.text !== b.originalText).length;
  const cutDuration = blocks.filter(b => b.deleted).reduce((s, b) => s + (b.end - b.start), 0);
  const totalDuration = blocks.length ? Math.max(...blocks.map(b => b.end)) : 0;
  const pct = totalDuration > 0 ? ((cutDuration / totalDuration) * 100).toFixed(1) : "0.0";

  document.getElementById("sumTotal").textContent = total;
  document.getElementById("sumRemoved").textContent = removed + (edited > 0 ? ` (+${edited} edited)` : "");
  document.getElementById("sumTimeCut").textContent = fmt(cutDuration);
  document.getElementById("sumReduction").textContent = pct + "%";
  document.getElementById("sumEstOutput").textContent = fmt(Math.max(0, totalDuration - cutDuration));
}

// ── Video sync ──
$videoPlayer.addEventListener("timeupdate", () => {
  if (!$syncToggle.checked) return;
  const t = $videoPlayer.currentTime;
  let active = -1;
  for (const b of blocks) {
    if (t >= b.start && t < b.end) { active = b.id; break; }
  }
  if (active === currentHighlight) return;
  currentHighlight = active;

  // Highlight in both panes
  [$originalPane, $editPane].forEach($pane => {
    $pane.querySelectorAll(".block-card.active").forEach(c => c.classList.remove("active"));
    if (active >= 0) {
      const card = $pane.querySelector(`[data-id="${active}"]`);
      if (card) card.classList.add("active");
    }
  });

  // Scroll the edit pane; original will follow via sync
  if (active >= 0 && $scrollSyncToggle.checked) {
    const card = $editPane.querySelector(`[data-id="${active}"]`);
    if (card) {
      const rect = card.getBoundingClientRect();
      const cRect = $editPane.getBoundingClientRect();
      if (rect.top < cRect.top + 40 || rect.bottom > cRect.bottom) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }
  }
});

function seekTo(time) {
  $videoPlayer.currentTime = time;
}

// ── Margin slider ──
$marginSlider.addEventListener("input", () => {
  $marginVal.textContent = parseFloat($marginSlider.value).toFixed(2) + "s";
});

// ── Advanced mode ──
function toggleAdvanced() {
  const panel = document.getElementById("advanced-panel");
  panel.classList.toggle("hidden");
  const btn = document.getElementById("advancedToggle");
  btn.textContent = panel.classList.contains("hidden") ? "Advanced" : "Simple";
}

// ── Settings ──
const SETTINGS_KEY = "papercut-settings";

const SETTINGS_DEFAULTS = {
  transcriptionEngine: "whisperx",
  whisperModel: "medium",
  language: "en",
  exportFormat: "final-cut-pro",
  margin: "0.10",
  silentSpeed: "",
  soundedSpeed: "",
  videoCodec: "",
  audioCodec: "",
  ffmpegArgs: "",
  editMethod: "",
  exportFolder: "",
  syncPlayback: "true",
  syncScroll: "true",
};

function loadSettings() {
  try {
    const saved = JSON.parse(localStorage.getItem(SETTINGS_KEY));
    return { ...SETTINGS_DEFAULTS, ...saved };
  } catch {
    return { ...SETTINGS_DEFAULTS };
  }
}

function applySettings() {
  const s = loadSettings();

  // Populate settings form
  document.getElementById("settTranscriptionEngine").value = s.transcriptionEngine;
  updateEngineFields();
  document.getElementById("settWhisperModel").value = s.whisperModel;
  document.getElementById("settLanguage").value = s.language;
  document.getElementById("settExportFormat").value = s.exportFormat;
  document.getElementById("settMargin").value = s.margin;
  document.getElementById("settSilentSpeed").value = s.silentSpeed;
  document.getElementById("settSoundedSpeed").value = s.soundedSpeed;
  document.getElementById("settVideoCodec").value = s.videoCodec;
  document.getElementById("settAudioCodec").value = s.audioCodec;
  document.getElementById("settFfmpegArgs").value = s.ffmpegArgs;
  document.getElementById("settEditMethod").value = s.editMethod;
  document.getElementById("settExportFolder").value = s.exportFolder;
  document.getElementById("settSyncPlayback").value = s.syncPlayback;
  document.getElementById("settSyncScroll").value = s.syncScroll;

  // Apply to main UI
  document.getElementById("exportFormat").value = s.exportFormat;
  $marginSlider.value = parseFloat(s.margin);
  $marginVal.textContent = parseFloat(s.margin).toFixed(2) + "s";
  document.getElementById("silentSpeed").value = s.silentSpeed;
  document.getElementById("soundedSpeed").value = s.soundedSpeed;
  document.getElementById("videoCodec").value = s.videoCodec;
  document.getElementById("audioCodec").value = s.audioCodec;
  document.getElementById("ffmpegArgs").value = s.ffmpegArgs;
  document.getElementById("editMethod").value = s.editMethod;
  $syncToggle.checked = s.syncPlayback === "true";
  $scrollSyncToggle.checked = s.syncScroll === "true";
}

function saveSettings() {
  const s = {
    transcriptionEngine: document.getElementById("settTranscriptionEngine").value,
    whisperModel: document.getElementById("settWhisperModel").value,
    language: document.getElementById("settLanguage").value,
    exportFormat: document.getElementById("settExportFormat").value,
    margin: document.getElementById("settMargin").value,
    silentSpeed: document.getElementById("settSilentSpeed").value.trim(),
    soundedSpeed: document.getElementById("settSoundedSpeed").value.trim(),
    videoCodec: document.getElementById("settVideoCodec").value.trim(),
    audioCodec: document.getElementById("settAudioCodec").value.trim(),
    ffmpegArgs: document.getElementById("settFfmpegArgs").value.trim(),
    editMethod: document.getElementById("settEditMethod").value.trim(),
    exportFolder: document.getElementById("settExportFolder").value.trim(),
    syncPlayback: document.getElementById("settSyncPlayback").value,
    syncScroll: document.getElementById("settSyncScroll").value,
  };
  localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  applySettings();
  toggleSettings();
}

function resetSettings() {
  localStorage.removeItem(SETTINGS_KEY);
  applySettings();
}

function updateEngineFields() {
  const engine = document.getElementById("settTranscriptionEngine").value;
  const whisperModelField = document.getElementById("settWhisperModelField");
  whisperModelField.style.display = engine === "crisperwhisper" ? "none" : "";
}

function toggleSettings() {
  document.getElementById("settingsOverlay").classList.toggle("hidden");
}

// Apply saved settings on load
applySettings();

// ── Export ──
function startExport() {
  if (!videoPath) return;

  const $btn = document.getElementById("exportBtn");
  $btn.disabled = true;
  $btn.textContent = "Exporting\u2026";
  $exportResult.classList.add("hidden");

  // Send originalText for diff matching (so user edits don't break cut detection)
  const keptBlocks = blocks.filter(b => !b.deleted).map(b => ({
    index: b.index,
    start: b.start,
    end: b.end,
    text: b.originalText,
  }));

  fetch("/api/diff", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      orig_srt_path: origSrtPath,
      json_path: jsonPath,
      kept_blocks: keptBlocks,
    }),
  })
  .then(r => r.json())
  .then(diffData => {
    if (diffData.error) throw new Error(diffData.error);
    deletedRanges = diffData.deleted_ranges;

    if (diffData.summary) {
      const s = diffData.summary;
      document.getElementById("sumTotal").textContent = s.total_blocks;
      document.getElementById("sumRemoved").textContent = s.removed_blocks;
      document.getElementById("sumTimeCut").textContent = fmt(s.cut_duration);
      document.getElementById("sumReduction").textContent = s.reduction_pct + "%";
    }

    const payload = {
      video_path: videoPath,
      deleted_ranges: deletedRanges,
      margin: parseFloat($marginSlider.value),
      export: document.getElementById("exportFormat").value,
      export_folder: loadSettings().exportFolder || "",
    };

    const silentSpeed = document.getElementById("silentSpeed").value.trim();
    const soundedSpeed = document.getElementById("soundedSpeed").value.trim();
    const videoCodec = document.getElementById("videoCodec").value.trim();
    const audioCodec = document.getElementById("audioCodec").value.trim();
    const ffmpegArgs = document.getElementById("ffmpegArgs").value.trim();
    const editMethod = document.getElementById("editMethod").value.trim();

    if (silentSpeed) payload.silent_speed = silentSpeed;
    if (soundedSpeed) payload.sounded_speed = soundedSpeed;
    if (videoCodec) payload.video_codec = videoCodec;
    if (audioCodec) payload.audio_codec = audioCodec;
    if (ffmpegArgs) payload.ffmpeg_args = ffmpegArgs;
    if (editMethod) payload.edit_method = editMethod;

    return fetch("/api/export", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
  })
  .then(r => r.json())
  .then(result => {
    $exportResult.classList.remove("hidden");
    if (result.success) {
      $exportResult.className = "success";
      $exportResult.textContent = `${result.message}\n\nCommand: ${result.command}`;
      if (result.stdout) $exportResult.textContent += `\n\n${result.stdout}`;
      clearAutosave();
    } else {
      $exportResult.className = "error";
      $exportResult.textContent = `Export failed: ${result.error}\n\nCommand: ${result.command || "N/A"}`;
    }
  })
  .catch(err => {
    $exportResult.classList.remove("hidden");
    $exportResult.className = "error";
    $exportResult.textContent = "Error: " + err.message;
  })
  .finally(() => {
    $btn.disabled = false;
    $btn.textContent = "Export";
  });
}

// ── Theme Toggle ──
function getTheme() {
  return localStorage.getItem("papercut-theme") || "light";
}

function applyTheme(theme) {
  document.documentElement.setAttribute("data-theme", theme);
  document.getElementById("themeToggle").textContent = theme === "dark" ? "\u2600" : "\u263E";
}

function toggleTheme() {
  const next = getTheme() === "dark" ? "light" : "dark";
  localStorage.setItem("papercut-theme", next);
  applyTheme(next);
}

applyTheme(getTheme());

// ── Feature 3: Export Presets ──
const PRESETS_KEY = "papercut-export-presets";

function getPresets() {
  try { return JSON.parse(localStorage.getItem(PRESETS_KEY)) || []; }
  catch { return []; }
}

function populatePresetDropdown() {
  const sel = document.getElementById("presetSelect");
  const presets = getPresets();
  sel.innerHTML = '<option value="">— None —</option>';
  presets.forEach((p, i) => {
    const opt = document.createElement("option");
    opt.value = i;
    opt.textContent = p.name;
    sel.appendChild(opt);
  });
}

function loadPreset() {
  const sel = document.getElementById("presetSelect");
  if (sel.value === "") return;
  const presets = getPresets();
  const p = presets[parseInt(sel.value)];
  if (!p) return;
  if (p.exportFormat) document.getElementById("exportFormat").value = p.exportFormat;
  if (p.margin != null) { $marginSlider.value = parseFloat(p.margin); $marginVal.textContent = parseFloat(p.margin).toFixed(2) + "s"; }
  if (p.silentSpeed != null) document.getElementById("silentSpeed").value = p.silentSpeed;
  if (p.soundedSpeed != null) document.getElementById("soundedSpeed").value = p.soundedSpeed;
  if (p.videoCodec != null) document.getElementById("videoCodec").value = p.videoCodec;
  if (p.audioCodec != null) document.getElementById("audioCodec").value = p.audioCodec;
  if (p.ffmpegArgs != null) document.getElementById("ffmpegArgs").value = p.ffmpegArgs;
  if (p.editMethod != null) document.getElementById("editMethod").value = p.editMethod;
}

function savePreset() {
  const name = prompt("Preset name:");
  if (!name) return;
  const preset = {
    name,
    exportFormat: document.getElementById("exportFormat").value,
    margin: $marginSlider.value,
    silentSpeed: document.getElementById("silentSpeed").value.trim(),
    soundedSpeed: document.getElementById("soundedSpeed").value.trim(),
    videoCodec: document.getElementById("videoCodec").value.trim(),
    audioCodec: document.getElementById("audioCodec").value.trim(),
    ffmpegArgs: document.getElementById("ffmpegArgs").value.trim(),
    editMethod: document.getElementById("editMethod").value.trim(),
  };
  const presets = getPresets();
  const existing = presets.findIndex(p => p.name === name);
  if (existing >= 0) presets[existing] = preset;
  else presets.push(preset);
  localStorage.setItem(PRESETS_KEY, JSON.stringify(presets));
  populatePresetDropdown();
  document.getElementById("presetSelect").value = presets.findIndex(p => p.name === name);
}

function deletePreset() {
  const sel = document.getElementById("presetSelect");
  if (sel.value === "") return;
  const presets = getPresets();
  presets.splice(parseInt(sel.value), 1);
  localStorage.setItem(PRESETS_KEY, JSON.stringify(presets));
  populatePresetDropdown();
}

populatePresetDropdown();

// ── Feature 4: Auto-save ──
let _autosaveTimer = null;

function getAutosaveKey() {
  const filename = videoPath.split("/").pop() || videoPath;
  return "papercut-autosave-" + filename;
}

function triggerAutosave() {
  clearTimeout(_autosaveTimer);
  _autosaveTimer = setTimeout(autosave, 500);
}

function autosave() {
  if (!videoPath || !blocks.length) return;
  const data = {
    videoPath,
    timestamp: Date.now(),
    blocks: blocks.map(b => ({ id: b.id, index: b.index, start: b.start, end: b.end, text: b.text, originalText: b.originalText, deleted: b.deleted })),
  };
  localStorage.setItem(getAutosaveKey(), JSON.stringify(data));
  // Flash "Saved" indicator
  $autosaveIndicator.style.opacity = "1";
  setTimeout(() => { $autosaveIndicator.style.opacity = "0"; }, 1500);
}

function checkAutosave() {
  if (!videoPath) return;
  const raw = localStorage.getItem(getAutosaveKey());
  if (!raw) return;
  try {
    const data = JSON.parse(raw);
    if (!data.blocks || !data.blocks.length) return;
    const ago = Date.now() - data.timestamp;
    const agoText = ago < 60000 ? "less than a minute ago"
      : ago < 3600000 ? Math.floor(ago / 60000) + " minutes ago"
      : Math.floor(ago / 3600000) + " hours ago";
    const cutCount = data.blocks.filter(b => b.deleted).length;
    const editedCount = data.blocks.filter(b => !b.deleted && b.text !== b.originalText).length;
    const msg = `Found auto-saved session from ${agoText}:\n• ${cutCount} blocks cut\n• ${editedCount} blocks edited\n\nRestore this session?`;
    if (confirm(msg)) {
      // Restore blocks state
      for (const saved of data.blocks) {
        const b = blocks.find(x => x.id === saved.id);
        if (!b) continue;
        b.text = saved.text;
        b.originalText = saved.originalText;
        b.deleted = saved.deleted;
      }
    }
  } catch {}
}

function clearAutosave() {
  if (videoPath) localStorage.removeItem(getAutosaveKey());
}

// ── Feature 5: Search/Find ──
function openSearch() {
  if (searchOpen) { document.getElementById("searchInput").focus(); return; }
  if ($transcriptSection.classList.contains("hidden")) return;
  searchOpen = true;

  const bar = document.createElement("div");
  bar.className = "search-bar";
  bar.id = "searchBar";
  bar.innerHTML = `
    <input type="text" id="searchInput" placeholder="Find in transcript\u2026" autocomplete="off">
    <span class="search-count" id="searchCount">0/0</span>
    <button class="btn btn-secondary btn-sm" onclick="searchNav(-1)">\u25B2</button>
    <button class="btn btn-secondary btn-sm" onclick="searchNav(1)">\u25BC</button>
    <button class="btn btn-secondary btn-sm" onclick="closeSearch()">\u2715</button>
  `;
  $transcriptSection.insertBefore(bar, $transcriptSection.firstChild);

  const input = document.getElementById("searchInput");
  input.addEventListener("input", () => performSearch());
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); searchNav(e.shiftKey ? -1 : 1); }
    if (e.key === "Escape") { e.preventDefault(); closeSearch(); }
  });
  input.focus();
}

function closeSearch() {
  searchOpen = false;
  searchMatches = [];
  currentMatchIndex = -1;
  const bar = document.getElementById("searchBar");
  if (bar) bar.remove();
  // Strip all <mark> tags
  $editPane.querySelectorAll("mark.search-highlight").forEach(m => {
    const parent = m.parentNode;
    parent.replaceChild(document.createTextNode(m.textContent), m);
    parent.normalize();
  });
}

function performSearch() {
  const input = document.getElementById("searchInput");
  if (!input) return;
  const query = input.value.trim().toLowerCase();

  // Clear previous highlights
  $editPane.querySelectorAll("mark.search-highlight").forEach(m => {
    const parent = m.parentNode;
    parent.replaceChild(document.createTextNode(m.textContent), m);
    parent.normalize();
  });
  searchMatches = [];
  currentMatchIndex = -1;

  if (!query) {
    document.getElementById("searchCount").textContent = "0/0";
    return;
  }

  // Walk text nodes in .block-text elements (edit pane only, non-cut)
  $editPane.querySelectorAll(".block-card:not(.is-cut) .block-text").forEach(textEl => {
    const blockId = parseInt(textEl.closest(".block-card").dataset.id);
    highlightTextNode(textEl, query, blockId);
  });

  document.getElementById("searchCount").textContent = searchMatches.length > 0
    ? `0/${searchMatches.length}` : "0/0";

  if (searchMatches.length > 0) {
    currentMatchIndex = 0;
    searchMatches[0].markEl.classList.add("current");
    document.getElementById("searchCount").textContent = `1/${searchMatches.length}`;
    searchMatches[0].markEl.scrollIntoView({ behavior: "smooth", block: "center" });
  }
}

function highlightTextNode(el, query, blockId) {
  const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  const nodesToProcess = [];
  while (walker.nextNode()) {
    nodesToProcess.push(walker.currentNode);
  }
  for (const node of nodesToProcess) {
    const text = node.textContent.toLowerCase();
    let idx = text.indexOf(query);
    if (idx === -1) continue;

    const frag = document.createDocumentFragment();
    let lastIdx = 0;
    const original = node.textContent;

    while (idx !== -1) {
      if (idx > lastIdx) frag.appendChild(document.createTextNode(original.slice(lastIdx, idx)));
      const mark = document.createElement("mark");
      mark.className = "search-highlight";
      mark.textContent = original.slice(idx, idx + query.length);
      frag.appendChild(mark);
      searchMatches.push({ blockId, markEl: mark });
      lastIdx = idx + query.length;
      idx = text.indexOf(query, lastIdx);
    }
    if (lastIdx < original.length) frag.appendChild(document.createTextNode(original.slice(lastIdx)));
    node.parentNode.replaceChild(frag, node);
  }
}

function searchNav(dir) {
  if (!searchMatches.length) return;
  if (currentMatchIndex >= 0) searchMatches[currentMatchIndex].markEl.classList.remove("current");
  currentMatchIndex = (currentMatchIndex + dir + searchMatches.length) % searchMatches.length;
  searchMatches[currentMatchIndex].markEl.classList.add("current");
  searchMatches[currentMatchIndex].markEl.scrollIntoView({ behavior: "smooth", block: "center" });
  document.getElementById("searchCount").textContent = `${currentMatchIndex + 1}/${searchMatches.length}`;
}

// ── Feature 6: Keyboard Navigation & Multi-Select ──
function setFocus(id) {
  // Remove old focus
  $editPane.querySelectorAll(".block-card.focused").forEach(c => c.classList.remove("focused"));
  focusedBlockId = id;
  const card = $editPane.querySelector(`[data-id="${id}"]`);
  if (card) {
    card.classList.add("focused");
    // Ensure visible
    const rect = card.getBoundingClientRect();
    const cRect = $editPane.getBoundingClientRect();
    if (rect.top < cRect.top || rect.bottom > cRect.bottom) {
      card.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
  }
  updateSelectionDisplay();
}

function moveFocus(direction) {
  const cards = Array.from($editPane.querySelectorAll(".block-card"));
  if (!cards.length) return;
  const ids = cards.map(c => parseInt(c.dataset.id));

  if (focusedBlockId === null) {
    setFocus(ids[direction > 0 ? 0 : ids.length - 1]);
    return;
  }

  const curIdx = ids.indexOf(focusedBlockId);
  if (curIdx === -1) { setFocus(ids[0]); return; }
  const nextIdx = curIdx + direction;
  if (nextIdx < 0 || nextIdx >= ids.length) return;
  selectedBlocks.clear();
  setFocus(ids[nextIdx]);
}

function selectRange(fromId, toId) {
  const cards = Array.from($editPane.querySelectorAll(".block-card"));
  const ids = cards.map(c => parseInt(c.dataset.id));
  const fromIdx = ids.indexOf(fromId);
  const toIdx = ids.indexOf(toId);
  if (fromIdx === -1 || toIdx === -1) return;
  const lo = Math.min(fromIdx, toIdx);
  const hi = Math.max(fromIdx, toIdx);
  selectedBlocks.clear();
  for (let i = lo; i <= hi; i++) selectedBlocks.add(ids[i]);
  setFocus(toId);
}

function updateSelectionDisplay() {
  $editPane.querySelectorAll(".block-card.selected").forEach(c => c.classList.remove("selected"));
  for (const id of selectedBlocks) {
    const card = $editPane.querySelector(`[data-id="${id}"]`);
    if (card) card.classList.add("selected");
  }
}

function cutSelectedBlocks() {
  const toCut = selectedBlocks.size > 0 ? [...selectedBlocks] : (focusedBlockId !== null ? [focusedBlockId] : []);
  if (!toCut.length) return;

  // Find next focus target
  const cards = Array.from($editPane.querySelectorAll(".block-card"));
  const ids = cards.map(c => parseInt(c.dataset.id));
  const lastCutIdx = Math.max(...toCut.map(id => ids.indexOf(id)));
  let nextFocusId = null;
  for (let i = lastCutIdx + 1; i < ids.length; i++) {
    if (!toCut.includes(ids[i])) { nextFocusId = ids[i]; break; }
  }
  if (nextFocusId === null) {
    for (let i = lastCutIdx - 1; i >= 0; i--) {
      if (!toCut.includes(ids[i])) { nextFocusId = ids[i]; break; }
    }
  }

  for (const id of toCut) cutBlock(id);
  selectedBlocks.clear();
  if (nextFocusId !== null) setFocus(nextFocusId);
}

// ── Clear All Cuts ──
function clearAllCuts() {
  const cutBlocks = blocks.filter(b => b.deleted);
  const editedBlocks = blocks.filter(b => !b.deleted && b.text !== b.originalText);
  if (!cutBlocks.length && !editedBlocks.length) return;

  const parts = [];
  if (cutBlocks.length) parts.push(`${cutBlocks.length} cut`);
  if (editedBlocks.length) parts.push(`${editedBlocks.length} edited`);
  if (!confirm(`Restore all blocks (${parts.join(", ")}) to original state?`)) return;

  for (const b of blocks) {
    if (b.deleted || b.text !== b.originalText) {
      b.deleted = false;
      b.text = b.originalText;
    }
  }
  undoStack = [];
  redoStack = [];
  $undoBtn.disabled = true;
  $redoBtn.disabled = true;
  renderTranscript();
  updateSummary();
  triggerAutosave();
}

// ── Auto-Edit: Clean Fillers ──
const FILLER_PATTERNS = [
  /^\s*(um+|uh+|uh-huh|mm+|hmm+|mhm+|hm+|ah+|eh+|oh+)\s*[.!?,]*\s*$/i,
  /^\s*(you know|i mean|like|so|right|okay|well|yeah|yep|nah)\s*[.!?,]*\s*$/i,
];

function isFillerBlock(text) {
  const trimmed = text.trim().replace(/[.!?,;:\s]+$/g, "").trim();
  if (!trimmed) return true; // empty block
  return FILLER_PATTERNS.some(rx => rx.test(trimmed));
}

function cleanFillers() {
  const toCut = blocks.filter(b => !b.deleted && isFillerBlock(b.text));
  if (!toCut.length) { alert("No filler blocks found."); return; }
  if (!confirm(`Cut ${toCut.length} filler block${toCut.length > 1 ? "s" : ""}?`)) return;

  for (const b of toCut) {
    b.deleted = true;
    undoStack.push({ type: "cut", id: b.id });
    updateEditBlock(b.id);
    updateOriginalBlock(b.id);
  }
  redoStack = [];
  $undoBtn.disabled = false;
  $redoBtn.disabled = true;
  updateSummary();
  triggerAutosave();
  if (searchOpen) performSearch();
}

// ── Auto-Edit: Dedupe Takes ──
function textSimilarity(a, b) {
  const wordsA = a.toLowerCase().replace(/[^\w\s]/g, "").split(/\s+/).filter(Boolean);
  const wordsB = b.toLowerCase().replace(/[^\w\s]/g, "").split(/\s+/).filter(Boolean);
  if (!wordsA.length || !wordsB.length) return 0;

  const setA = new Set(wordsA);
  const setB = new Set(wordsB);
  const intersection = [...setA].filter(w => setB.has(w)).length;
  const union = new Set([...setA, ...setB]).size;
  return union > 0 ? intersection / union : 0;
}

function dedupeTakes() {
  const SIMILARITY_THRESHOLD = 0.6;
  const toCut = [];

  // Walk non-deleted blocks in order, find runs of similar consecutive blocks
  const active = blocks.filter(b => !b.deleted);
  let i = 0;
  while (i < active.length) {
    // Start a run from block i
    let runEnd = i;
    while (runEnd + 1 < active.length &&
           textSimilarity(active[i].text, active[runEnd + 1].text) >= SIMILARITY_THRESHOLD) {
      runEnd++;
    }

    if (runEnd > i) {
      // Found a run of similar blocks from i to runEnd — cut all but the last
      for (let j = i; j < runEnd; j++) {
        toCut.push(active[j]);
      }
    }
    i = runEnd + 1;
  }

  if (!toCut.length) { alert("No repeated takes found."); return; }
  if (!confirm(`Found ${toCut.length} repeated take${toCut.length > 1 ? "s" : ""} to cut (keeping last of each run). Proceed?`)) return;

  for (const b of toCut) {
    b.deleted = true;
    undoStack.push({ type: "cut", id: b.id });
    updateEditBlock(b.id);
    updateOriginalBlock(b.id);
  }
  redoStack = [];
  $undoBtn.disabled = false;
  $redoBtn.disabled = true;
  updateSummary();
  triggerAutosave();
  if (searchOpen) performSearch();
}

// ── Keyboard shortcuts ──
document.addEventListener("keydown", (e) => {
  const inInput = e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable;

  // Ctrl+Z / Cmd+Z — Undo
  if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
    if (inInput) return;
    e.preventDefault();
    undoLast();
    return;
  }

  // Ctrl+Shift+Z / Cmd+Shift+Z — Redo
  if ((e.ctrlKey || e.metaKey) && (e.key === "Z" || (e.key === "z" && e.shiftKey))) {
    if (inInput) return;
    e.preventDefault();
    redoLast();
    return;
  }

  // Ctrl+Y / Cmd+Y — Redo (alternative)
  if ((e.ctrlKey || e.metaKey) && e.key === "y") {
    if (inInput) return;
    e.preventDefault();
    redoLast();
    return;
  }

  // Ctrl+F / Cmd+F — Search
  if ((e.ctrlKey || e.metaKey) && e.key === "f") {
    if (!$transcriptSection.classList.contains("hidden")) {
      e.preventDefault();
      openSearch();
      return;
    }
  }

  // Escape — close search
  if (e.key === "Escape" && searchOpen) {
    closeSearch();
    return;
  }

  // Arrow keys and Delete — keyboard nav (only when not in input)
  if (inInput || e.target.closest("input,textarea,select")) return;
  if ($transcriptSection.classList.contains("hidden")) return;

  if (e.key === "ArrowUp") {
    e.preventDefault();
    moveFocus(-1);
  } else if (e.key === "ArrowDown") {
    e.preventDefault();
    moveFocus(1);
  } else if (e.key === "Delete" || e.key === "Backspace") {
    e.preventDefault();
    cutSelectedBlocks();
  }
});

// ── Strip search highlights on contenteditable focus ──
$editPane.addEventListener("focusin", (e) => {
  if (e.target.isContentEditable && searchOpen) {
    e.target.querySelectorAll("mark.search-highlight").forEach(m => {
      const parent = m.parentNode;
      parent.replaceChild(document.createTextNode(m.textContent), m);
      parent.normalize();
    });
  }
});

</script>
</body>
</html>
