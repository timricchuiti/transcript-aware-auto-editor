<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Transcript-Aware Auto-Editor</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --blue: #48A8DD;
  --blue-light: #e8f4fb;
  --blue-pale: #f2f9fd;
  --green: #61B87B;
  --green-light: #eaf6ee;
  --sunray: #EDAE49;
  --sunray-light: #fdf5e6;
  --brick: #D1495B;
  --brick-light: #fbeaec;
  --indigo: #003D5B;
  --ink: #011627;
  --bg: #FDFFFC;
  --bg-page: #F7F8F5;
  --bg-surface: #FFFFFF;
  --border: #E2E4DE;
  --border-light: #EEEFE9;
  --text: #1A1F2B;
  --text-secondary: #5A6275;
  --text-dim: #8E94A4;
  --font-display: 'DM Sans', system-ui, sans-serif;
  --font-script: 'Courier Prime', 'Courier New', Courier, monospace;
  --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
  --radius: 8px;
  --radius-lg: 12px;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
  --shadow-lg: 0 8px 30px rgba(0,0,0,0.10);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: var(--font-display);
  background: var(--bg-page);
  color: var(--text);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
}

.hidden { display: none !important; }

/* ── Layout ── */
.container {
  max-width: 960px;
  margin: 0 auto;
  padding: 0 24px;
}
.container-wide {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 24px;
}

/* ── Header ── */
header {
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  padding: 16px 0;
}
header .container-wide {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
header h1 {
  font-family: var(--font-display);
  font-size: 18px;
  font-weight: 600;
  color: var(--indigo);
}
header h1 span { color: var(--blue); }
#advancedToggle {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 6px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-display);
  font-size: 13px;
  font-weight: 500;
  transition: all 0.15s;
}
#advancedToggle:hover {
  border-color: var(--blue);
  color: var(--blue);
}

/* ── Drop Zone ── */
.drop-zone-wrap {
  padding: 32px 0 24px;
}
.drop-zone {
  border: 2px dashed var(--border);
  border-radius: var(--radius-lg);
  padding: 48px 24px;
  text-align: center;
  transition: all 0.2s;
  cursor: pointer;
  background: var(--bg-surface);
}
.drop-zone.dragover {
  border-color: var(--blue);
  background: var(--blue-pale);
  box-shadow: 0 0 0 4px rgba(72, 168, 221, 0.1);
}
.drop-zone.uploading { pointer-events: none; opacity: 0.7; }
.drop-zone-icon {
  font-size: 36px;
  margin-bottom: 12px;
  color: var(--text-dim);
}
.drop-zone-text {
  font-size: 15px;
  color: var(--text-secondary);
  margin-bottom: 6px;
}
.drop-zone-text strong { color: var(--blue); }
.drop-zone-hint {
  font-size: 12px;
  color: var(--text-dim);
}
.drop-zone-file-input { display: none; }
.drop-alt {
  margin-top: 16px;
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.drop-alt-divider {
  font-size: 12px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}
.path-input {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 14px;
  border-radius: 6px;
  font-family: var(--font-mono);
  font-size: 12px;
  width: 360px;
  transition: border-color 0.15s;
}
.path-input:focus { outline: none; border-color: var(--blue); }

/* ── Buttons ── */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-family: var(--font-display);
  font-weight: 500;
  font-size: 13px;
  border: none;
  transition: all 0.15s;
  white-space: nowrap;
}
.btn-primary {
  background: var(--blue);
  color: #fff;
}
.btn-primary:hover { background: #3a9ad0; }
.btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-secondary {
  background: var(--bg-surface);
  color: var(--text-secondary);
  border: 1px solid var(--border);
}
.btn-secondary:hover { border-color: var(--blue); color: var(--blue); }
.btn-danger-outline {
  background: none;
  color: var(--brick);
  border: 1px solid var(--brick-light);
}
.btn-danger-outline:hover {
  background: var(--brick-light);
  border-color: var(--brick);
}
.btn-success-outline {
  background: none;
  color: var(--green);
  border: 1px solid var(--green-light);
}
.btn-success-outline:hover {
  background: var(--green-light);
  border-color: var(--green);
}
.btn-sm { padding: 5px 12px; font-size: 12px; }

/* ── Progress Log ── */
#progress-section { padding: 0 0 24px; }
#progress-log {
  background: var(--ink);
  color: #b0bec5;
  border-radius: var(--radius);
  padding: 16px;
  font-family: var(--font-mono);
  font-size: 12px;
  max-height: 180px;
  overflow-y: auto;
  line-height: 1.7;
}
#progress-log .line { white-space: pre-wrap; word-break: break-all; }
#progress-log .line::before { content: "> "; color: #546e7a; }
#progress-log .line-error { color: var(--brick); }
#progress-log .line-error::before { content: "! "; color: var(--brick); }
#progress-log .line-done { color: var(--green); }
#progress-log .line-done::before { content: "\2713 "; color: var(--green); }

/* ── Video Section ── */
#video-section { padding-bottom: 0; }
.video-wrap {
  background: #000;
  border-radius: var(--radius-lg);
  overflow: hidden;
  box-shadow: var(--shadow-lg);
}
video { width: 100%; display: block; max-height: 400px; }

.video-toolbar {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 10px 0 0;
}
.video-toolbar label {
  font-size: 12px;
  color: var(--text-dim);
  display: flex;
  align-items: center;
  gap: 5px;
  cursor: pointer;
}
.video-toolbar input[type="checkbox"] { accent-color: var(--blue); }

/* ── Stats Bar ── */
#summary-bar {
  display: flex;
  gap: 0;
  margin: 20px 0;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  overflow: hidden;
  box-shadow: var(--shadow-sm);
}
.stat-card {
  flex: 1;
  padding: 14px 18px;
  text-align: center;
  border-right: 1px solid var(--border-light);
}
.stat-card:last-child { border-right: none; }
.stat-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  color: var(--text-dim);
  margin-bottom: 4px;
}
.stat-val {
  font-family: var(--font-mono);
  font-size: 20px;
  font-weight: 500;
  color: var(--indigo);
}
.stat-card.stat-danger .stat-val { color: var(--brick); }
.stat-card.stat-accent .stat-val { color: var(--blue); }

/* ── Transcript Two-Column ── */
#transcript-section { padding-bottom: 24px; }
.transcript-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.transcript-col-headers {
  display: flex;
  flex: 1;
  gap: 16px;
}
.transcript-col-label {
  flex: 1;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
}
.transcript-col-label.label-edit { text-align: left; }

.transcript-columns {
  display: flex;
  gap: 16px;
  align-items: stretch;
}

.script-page {
  flex: 1;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  max-height: 55vh;
  overflow-y: auto;
}
.script-page.pane-original {
  border-left: 3px solid var(--border);
}
.script-page.pane-edit {
  border-left: 3px solid var(--blue);
}

/* Block cards */
.block-card {
  padding: 14px 20px;
  border-bottom: 1px solid var(--border-light);
  transition: background 0.15s;
  position: relative;
  animation: fadeSlideIn 0.3s ease-out both;
}
@keyframes fadeSlideIn {
  from { opacity: 0; transform: translateY(4px); }
  to { opacity: 1; transform: translateY(0); }
}
.block-card:last-child { border-bottom: none; }
.block-card:hover { background: var(--bg-page); }
.block-card.active {
  background: var(--blue-pale);
  box-shadow: inset 3px 0 0 var(--blue);
}

.block-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}
.block-meta-left {
  display: flex;
  align-items: center;
  gap: 10px;
}
.block-number {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 500;
  color: var(--text-dim);
  background: var(--bg-page);
  padding: 2px 8px;
  border-radius: 4px;
  min-width: 28px;
  text-align: center;
}
.block-time {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--text-dim);
  cursor: pointer;
}
.block-time:hover { color: var(--blue); }
.block-actions {
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0;
  transition: opacity 0.15s;
}
.block-card:hover .block-actions { opacity: 1; }

.block-text {
  font-family: var(--font-script);
  font-size: 14px;
  line-height: 1.65;
  color: var(--text);
  min-height: 1.65em;
  outline: none;
  padding: 2px 0;
  border-bottom: 1px solid transparent;
  transition: border-color 0.15s;
}
.block-text:focus {
  border-bottom-color: var(--blue);
}
.block-text[contenteditable="true"]::selection {
  background: var(--blue-light);
}

/* ── Cut blocks (edit pane) ── */
.pane-edit .block-card.is-cut {
  background: var(--brick-light);
  opacity: 0.7;
}
.pane-edit .block-card.is-cut .block-number { background: var(--brick-light); color: var(--brick); }
.pane-edit .block-card.is-cut .block-text {
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  color: var(--text-dim);
  font-style: italic;
}
.pane-edit .block-card.is-cut .block-actions { opacity: 1; }

/* ── Cut blocks (original pane) ── */
.pane-original .block-card.is-cut {
  background: var(--brick-light);
}
.pane-original .block-card.is-cut .block-number { background: var(--brick-light); color: var(--brick); }
.pane-original .block-card.is-cut .block-text {
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  color: var(--brick);
}

/* ── Word-level diff marks (original pane) ── */
.diff-del {
  color: var(--brick);
  background: var(--brick-light);
  text-decoration: line-through;
  text-decoration-color: var(--brick);
  border-radius: 2px;
  padding: 0 2px;
}
.diff-ok {
  /* default — no special styling */
}

/* ── Cut badge ── */
.cut-badge {
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--brick);
  background: #fff;
  border: 1px solid var(--brick);
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ── Edited badge ── */
.edited-badge {
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 500;
  color: var(--sunray);
  background: var(--sunray-light);
  border: 1px solid var(--sunray);
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* ── Export Section ── */
#export-section {
  padding: 24px 0;
}
.export-bar {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  flex-wrap: wrap;
  box-shadow: var(--shadow-sm);
}
.export-field {
  display: flex;
  align-items: center;
  gap: 8px;
}
.export-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.export-bar select,
.export-bar input[type="range"] {
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 13px;
  font-family: var(--font-display);
  padding: 6px 10px;
  background: #fff;
  color: var(--text);
}
.export-bar input[type="range"] { width: 120px; accent-color: var(--blue); }
.range-val {
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--blue);
  min-width: 40px;
}
.export-spacer { flex: 1; }

/* ── Advanced Panel ── */
#advanced-panel {
  padding-bottom: 24px;
}
.advanced-card {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 24px;
  box-shadow: var(--shadow-sm);
}
.advanced-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 14px;
}
.advanced-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 14px;
}
.advanced-grid label {
  display: flex;
  flex-direction: column;
  gap: 5px;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}
.advanced-grid input {
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text);
  background: #fff;
  transition: border-color 0.15s;
}
.advanced-grid input:focus { outline: none; border-color: var(--blue); }

/* ── Export Result ── */
#export-result {
  margin-bottom: 24px;
  padding: 16px 20px;
  border-radius: var(--radius);
  font-family: var(--font-mono);
  font-size: 12px;
  white-space: pre-wrap;
  line-height: 1.6;
}
#export-result.success {
  background: var(--green-light);
  color: #2d6e3f;
  border: 1px solid var(--green);
}
#export-result.error {
  background: var(--brick-light);
  color: var(--brick);
  border: 1px solid var(--brick);
}

/* ── Scrollbar ── */
.script-page::-webkit-scrollbar { width: 6px; }
.script-page::-webkit-scrollbar-track { background: transparent; }
.script-page::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.script-page::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

/* ── Stagger delays ── */
.script-page .block-card:nth-child(1) { animation-delay: 0.02s; }
.script-page .block-card:nth-child(2) { animation-delay: 0.04s; }
.script-page .block-card:nth-child(3) { animation-delay: 0.06s; }
.script-page .block-card:nth-child(4) { animation-delay: 0.08s; }
.script-page .block-card:nth-child(5) { animation-delay: 0.10s; }
.script-page .block-card:nth-child(6) { animation-delay: 0.12s; }
.script-page .block-card:nth-child(7) { animation-delay: 0.14s; }
.script-page .block-card:nth-child(8) { animation-delay: 0.16s; }
.script-page .block-card:nth-child(9) { animation-delay: 0.18s; }
.script-page .block-card:nth-child(n+10) { animation-delay: 0.20s; }
</style>
</head>
<body>

<header>
  <div class="container-wide">
    <h1>Transcript-Aware <span>Auto-Editor</span></h1>
    <button id="advancedToggle" onclick="toggleAdvanced()">Advanced</button>
  </div>
</header>

<div class="container">

  <!-- Drop Zone -->
  <div class="drop-zone-wrap">
    <div class="drop-zone" id="dropZone">
      <div class="drop-zone-icon">&#127916;</div>
      <div class="drop-zone-text">Drop a video file here or <strong>click to browse</strong></div>
      <div class="drop-zone-hint">mp4, mov, mkv, avi, webm</div>
      <input type="file" class="drop-zone-file-input" id="fileInput" accept="video/*">
    </div>
    <div class="drop-alt">
      <span class="drop-alt-divider">or</span>
      <input type="text" class="path-input" id="videoPath" placeholder="paste a local path" spellcheck="false">
      <button class="btn btn-secondary btn-sm" id="loadExistingBtn" onclick="loadExisting()">Load Existing</button>
    </div>
  </div>

  <!-- Progress log -->
  <div class="hidden" id="progress-section">
    <div id="progress-log"></div>
  </div>

  <!-- Video player -->
  <div class="hidden" id="video-section">
    <div class="video-wrap">
      <video id="videoPlayer" controls preload="metadata"></video>
    </div>
    <div class="video-toolbar">
      <label><input type="checkbox" id="syncToggle" checked> Sync playback</label>
      <label><input type="checkbox" id="scrollSyncToggle" checked> Sync scroll</label>
    </div>
  </div>

  <!-- Stats bar -->
  <div id="summary-bar" class="hidden">
    <div class="stat-card">
      <div class="stat-label">Blocks</div>
      <div class="stat-val" id="sumTotal">0</div>
    </div>
    <div class="stat-card stat-danger">
      <div class="stat-label">Cut</div>
      <div class="stat-val" id="sumRemoved">0</div>
    </div>
    <div class="stat-card stat-accent">
      <div class="stat-label">Time Removed</div>
      <div class="stat-val" id="sumTimeCut">0.0s</div>
    </div>
    <div class="stat-card stat-accent">
      <div class="stat-label">Reduction</div>
      <div class="stat-val" id="sumReduction">0%</div>
    </div>
  </div>

</div><!-- /.container -->

<!-- Transcript uses wider container for two columns -->
<div class="container-wide">

  <div id="transcript-section" class="hidden">
    <div class="transcript-header">
      <div class="transcript-col-headers">
        <div class="transcript-col-label">Original</div>
        <div class="transcript-col-label label-edit">Edit</div>
      </div>
      <button class="btn btn-secondary btn-sm" id="undoBtn" onclick="undoLast()" disabled>Undo</button>
    </div>
    <div class="transcript-columns">
      <div class="script-page pane-original" id="originalPane"></div>
      <div class="script-page pane-edit" id="editPane"></div>
    </div>
  </div>

  <!-- Export controls -->
  <div class="hidden" id="export-section">
    <div class="export-bar">
      <div class="export-field">
        <span class="export-label">Margin</span>
        <input type="range" id="marginSlider" min="0" max="1" step="0.05" value="0.10">
        <span class="range-val" id="marginVal">0.10s</span>
      </div>
      <div class="export-field">
        <span class="export-label">Format</span>
        <select id="exportFormat">
          <option value="final-cut-pro">Final Cut Pro</option>
          <option value="premiere">Premiere</option>
          <option value="resolve">DaVinci Resolve</option>
          <option value="clip-sequence">Clip Sequence</option>
          <option value="video">Video</option>
        </select>
      </div>
      <div class="export-spacer"></div>
      <button class="btn btn-primary" id="exportBtn" onclick="startExport()">Export</button>
    </div>
  </div>

  <!-- Advanced panel -->
  <div id="advanced-panel" class="hidden">
    <div class="advanced-card">
      <div class="advanced-title">Advanced Options</div>
      <div class="advanced-grid">
        <label>Silent speed <input type="text" id="silentSpeed" placeholder="99999 (cut)"></label>
        <label>Sounded speed <input type="text" id="soundedSpeed" placeholder="1"></label>
        <label>Video codec <input type="text" id="videoCodec" placeholder="auto"></label>
        <label>Audio codec <input type="text" id="audioCodec" placeholder="auto"></label>
        <label>FFmpeg args <input type="text" id="ffmpegArgs" placeholder="-crf 22 -preset veryfast"></label>
        <label>Edit method <input type="text" id="editMethod" placeholder="audio:threshold=4%"></label>
      </div>
    </div>
  </div>

  <!-- Export result -->
  <div id="export-result" class="hidden"></div>

</div><!-- /.container-wide -->

<script>
// ── State ──
let blocks = [];       // {id, index, start, end, text, originalText, deleted}
let undoStack = [];    // [{type: 'cut'|'edit', id, prevText?}]
let videoPath = "";
let srtPath = "";
let origSrtPath = "";
let jsonPath = "";
let currentHighlight = -1;
let deletedRanges = [];
let scrollSyncing = false;

// ── DOM refs ──
const $dropZone = document.getElementById("dropZone");
const $fileInput = document.getElementById("fileInput");
const $videoPathInput = document.getElementById("videoPath");
const $progressSection = document.getElementById("progress-section");
const $progressLog = document.getElementById("progress-log");
const $videoSection = document.getElementById("video-section");
const $videoPlayer = document.getElementById("videoPlayer");
const $syncToggle = document.getElementById("syncToggle");
const $scrollSyncToggle = document.getElementById("scrollSyncToggle");
const $transcriptSection = document.getElementById("transcript-section");
const $originalPane = document.getElementById("originalPane");
const $editPane = document.getElementById("editPane");
const $exportSection = document.getElementById("export-section");
const $marginSlider = document.getElementById("marginSlider");
const $marginVal = document.getElementById("marginVal");
const $undoBtn = document.getElementById("undoBtn");
const $summaryBar = document.getElementById("summary-bar");
const $exportResult = document.getElementById("export-result");

// ── Utilities ──
function fmt(sec) {
  const m = Math.floor(sec / 60);
  const s = (sec % 60).toFixed(1);
  return m > 0 ? `${m}:${s.padStart(4, '0')}` : `${s}s`;
}

function logLine(msg, cls = "") {
  const div = document.createElement("div");
  div.className = "line" + (cls ? ` line-${cls}` : "");
  div.textContent = msg;
  $progressLog.appendChild(div);
  $progressLog.scrollTop = $progressLog.scrollHeight;
}

function escHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// ── Word-Level Diff ──
// Uses LCS to find which words from the original were deleted
function wordDiff(original, edited) {
  const a = original.split(/(\s+)/).filter(s => s.length > 0);
  const b = edited.split(/(\s+)/).filter(s => s.length > 0);

  // Extract just the words (non-whitespace) for comparison
  const aWords = a.filter(s => s.trim().length > 0);
  const bWords = b.filter(s => s.trim().length > 0);

  const m = aWords.length, n = bWords.length;

  // Build LCS table
  const dp = [];
  for (let i = 0; i <= m; i++) {
    dp[i] = new Array(n + 1).fill(0);
  }
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (aWords[i - 1] === bWords[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  // Backtrack to find which original words are kept vs deleted
  const result = []; // {word, deleted: bool}
  let i = m, j = n;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && aWords[i - 1] === bWords[j - 1]) {
      result.unshift({ word: aWords[i - 1], deleted: false });
      i--; j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      // Word added in edited — skip (not shown on left)
      j--;
    } else {
      result.unshift({ word: aWords[i - 1], deleted: true });
      i--;
    }
  }
  return result;
}

function renderDiffHtml(original, edited) {
  if (original === edited) return escHtml(original);

  const diff = wordDiff(original, edited);
  return diff.map(({ word, deleted }) =>
    deleted
      ? `<span class="diff-del">${escHtml(word)}</span>`
      : escHtml(word)
  ).join(" ");
}

// ── Drag & Drop ──
$dropZone.addEventListener("click", () => $fileInput.click());
$fileInput.addEventListener("change", (e) => {
  if (e.target.files.length) uploadFile(e.target.files[0]);
});

$dropZone.addEventListener("dragover", (e) => {
  e.preventDefault();
  $dropZone.classList.add("dragover");
});
$dropZone.addEventListener("dragleave", () => {
  $dropZone.classList.remove("dragover");
});
$dropZone.addEventListener("drop", (e) => {
  e.preventDefault();
  $dropZone.classList.remove("dragover");
  const file = e.dataTransfer.files[0];
  if (file) uploadFile(file);
});

function uploadFile(file) {
  $dropZone.classList.add("uploading");
  $dropZone.querySelector(".drop-zone-text").textContent = `Uploading ${file.name}...`;

  const form = new FormData();
  form.append("file", file);

  fetch("/api/upload", { method: "POST", body: form })
    .then(r => r.json())
    .then(data => {
      if (data.error) throw new Error(data.error);
      videoPath = data.path;
      $videoPathInput.value = videoPath;
      $dropZone.querySelector(".drop-zone-text").innerHTML = `<strong>${data.filename}</strong> ready`;
      $dropZone.classList.remove("uploading");
      startTranscribe();
    })
    .catch(err => {
      $dropZone.querySelector(".drop-zone-text").textContent = "Upload failed: " + err.message;
      $dropZone.classList.remove("uploading");
    });
}

// ── Transcription ──
function startTranscribe() {
  const path = videoPath || $videoPathInput.value.trim();
  if (!path) return;
  videoPath = path;

  $progressSection.classList.remove("hidden");
  $progressLog.innerHTML = "";

  fetch("/api/transcribe", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ video_path: path }),
  }).then(response => {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    function read() {
      reader.read().then(({ done, value }) => {
        if (done) return;
        buf += decoder.decode(value, { stream: true });
        const lines = buf.split("\n");
        buf = lines.pop();
        for (const line of lines) {
          if (!line.startsWith("data: ")) continue;
          try {
            const evt = JSON.parse(line.slice(6));
            if (evt.type === "progress") logLine(evt.message);
            else if (evt.type === "start") logLine(evt.message);
            else if (evt.type === "error") logLine(evt.message, "error");
            else if (evt.type === "done") {
              logLine(evt.message, "done");
              srtPath = evt.srt_path;
              origSrtPath = evt.orig_srt_path;
              jsonPath = evt.json_path;
              loadTranscript();
            }
          } catch (_) {}
        }
        read();
      });
    }
    read();
  }).catch(err => {
    logLine("Request failed: " + err.message, "error");
  });
}

// ── Load Existing ──
function loadExisting() {
  const path = $videoPathInput.value.trim();
  if (!path) return;
  videoPath = path;

  const base = path.replace(/\.[^.]+$/, "");
  srtPath = base + ".srt";
  origSrtPath = base + ".srt.orig";
  jsonPath = base + ".json";
  loadTranscript();
}

// ── Load Transcript ──
function loadTranscript() {
  $videoPlayer.src = `/media?path=${encodeURIComponent(videoPath)}`;
  $videoSection.classList.remove("hidden");

  fetch(`/api/srt?path=${encodeURIComponent(origSrtPath)}`)
    .then(r => {
      if (!r.ok) return fetch(`/api/srt?path=${encodeURIComponent(srtPath)}`).then(r2 => r2.json());
      return r.json();
    })
    .then(data => {
      blocks = data.map((b, i) => ({
        id: i,
        index: b.index,
        start: b.start,
        end: b.end,
        text: b.text,
        originalText: b.text,
        deleted: false,
      }));
      undoStack = [];
      $undoBtn.disabled = true;
      renderTranscript();
      $transcriptSection.classList.remove("hidden");
      $exportSection.classList.remove("hidden");
      $summaryBar.classList.remove("hidden");
      updateSummary();
    })
    .catch(err => {
      $progressSection.classList.remove("hidden");
      logLine("Failed to load SRT: " + err.message, "error");
    });
}

// ── Render Both Panes ──
function renderTranscript() {
  renderOriginalPane();
  renderEditPane();
  bindEditPaneEvents();
  bindScrollSync();
}

function renderOriginalPane() {
  $originalPane.innerHTML = "";

  for (const b of blocks) {
    const card = document.createElement("div");
    card.className = "block-card" + (b.deleted ? " is-cut" : "");
    card.dataset.id = b.id;
    card.dataset.start = b.start;
    card.dataset.end = b.end;

    const isEdited = !b.deleted && b.text !== b.originalText;
    const badgeHtml = b.deleted
      ? `<span class="cut-badge">\u2702 CUT</span>`
      : (isEdited ? `<span class="edited-badge">\u270E Edited</span>` : "");

    const textHtml = b.deleted
      ? escHtml(b.originalText)
      : renderDiffHtml(b.originalText, b.text);

    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          ${badgeHtml}
        </div>
      </div>
      <div class="block-text">${textHtml}</div>
    `;

    card.addEventListener("click", () => seekTo(b.start));
    $originalPane.appendChild(card);
  }
}

function renderEditPane() {
  $editPane.innerHTML = "";

  for (const b of blocks) {
    const card = document.createElement("div");
    card.className = "block-card" + (b.deleted ? " is-cut" : "");
    card.dataset.id = b.id;
    card.dataset.start = b.start;
    card.dataset.end = b.end;

    if (b.deleted) {
      card.innerHTML = `
        <div class="block-meta">
          <div class="block-meta-left">
            <span class="block-number">${b.index ?? b.id + 1}</span>
            <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
            <span class="cut-badge">\u2702 CUT</span>
          </div>
          <div class="block-actions" style="opacity:1">
            <button class="btn btn-success-outline btn-sm" data-restore="${b.id}">Restore</button>
          </div>
        </div>
        <div class="block-text">${escHtml(b.originalText)}</div>
      `;
    } else {
      card.innerHTML = `
        <div class="block-meta">
          <div class="block-meta-left">
            <span class="block-number">${b.index ?? b.id + 1}</span>
            <span class="block-time" data-seek="${b.start}">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          </div>
          <div class="block-actions">
            <button class="btn btn-danger-outline btn-sm" data-cut="${b.id}">Cut</button>
          </div>
        </div>
        <div class="block-text" contenteditable="true" data-block-id="${b.id}">${escHtml(b.text)}</div>
      `;
    }

    $editPane.appendChild(card);
  }
}

function bindEditPaneEvents() {
  // Cut buttons
  $editPane.querySelectorAll("[data-cut]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      cutBlock(parseInt(btn.dataset.cut));
    });
  });

  // Restore buttons
  $editPane.querySelectorAll("[data-restore]").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      restoreBlock(parseInt(btn.dataset.restore));
    });
  });

  // Seek on timestamp click
  $editPane.querySelectorAll("[data-seek]").forEach(el => {
    el.addEventListener("click", () => seekTo(parseFloat(el.dataset.seek)));
  });

  // Text editing — update on blur, sync to left
  $editPane.querySelectorAll('.block-text[contenteditable="true"]').forEach(el => {
    el.addEventListener("blur", () => {
      const id = parseInt(el.dataset.blockId);
      const b = blocks.find(x => x.id === id);
      if (!b) return;
      const newText = el.textContent.trim();
      if (newText !== b.text) {
        // Push undo for text edit
        undoStack.push({ type: "edit", id: b.id, prevText: b.text });
        $undoBtn.disabled = false;
        b.text = newText;
        updateOriginalBlock(b.id);
        updateSummary();
      }
    });
    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); el.blur(); }
    });
  });

  // Click card to seek (but not on buttons or editable text)
  $editPane.querySelectorAll(".block-card").forEach(card => {
    card.addEventListener("click", (e) => {
      if (e.target.closest("button") || e.target.closest('[contenteditable="true"]')) return;
      seekTo(parseFloat(card.dataset.start));
    });
  });
}

// ── Update single block on original pane (after text edit) ──
function updateOriginalBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b) return;

  const card = $originalPane.querySelector(`[data-id="${id}"]`);
  if (!card) return;

  const isEdited = !b.deleted && b.text !== b.originalText;
  const badgeHtml = b.deleted
    ? `<span class="cut-badge">\u2702 CUT</span>`
    : (isEdited ? `<span class="edited-badge">\u270E Edited</span>` : "");

  const textHtml = b.deleted
    ? escHtml(b.originalText)
    : renderDiffHtml(b.originalText, b.text);

  card.className = "block-card" + (b.deleted ? " is-cut" : "");
  card.innerHTML = `
    <div class="block-meta">
      <div class="block-meta-left">
        <span class="block-number">${b.index ?? b.id + 1}</span>
        <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
        ${badgeHtml}
      </div>
    </div>
    <div class="block-text">${textHtml}</div>
  `;
  card.addEventListener("click", () => seekTo(b.start));
}

// ── Update single block on edit pane ──
function updateEditBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b) return;

  const card = $editPane.querySelector(`[data-id="${id}"]`);
  if (!card) return;

  card.className = "block-card" + (b.deleted ? " is-cut" : "");

  if (b.deleted) {
    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
          <span class="cut-badge">\u2702 CUT</span>
        </div>
        <div class="block-actions" style="opacity:1">
          <button class="btn btn-success-outline btn-sm" data-restore="${b.id}">Restore</button>
        </div>
      </div>
      <div class="block-text">${escHtml(b.originalText)}</div>
    `;
    card.querySelector("[data-restore]").addEventListener("click", (e) => {
      e.stopPropagation();
      restoreBlock(b.id);
    });
  } else {
    card.innerHTML = `
      <div class="block-meta">
        <div class="block-meta-left">
          <span class="block-number">${b.index ?? b.id + 1}</span>
          <span class="block-time" data-seek="${b.start}">${fmt(b.start)} \u2013 ${fmt(b.end)}</span>
        </div>
        <div class="block-actions">
          <button class="btn btn-danger-outline btn-sm" data-cut="${b.id}">Cut</button>
        </div>
      </div>
      <div class="block-text" contenteditable="true" data-block-id="${b.id}">${escHtml(b.text)}</div>
    `;
    card.querySelector("[data-cut]").addEventListener("click", (e) => {
      e.stopPropagation();
      cutBlock(b.id);
    });
    card.querySelector("[data-seek]").addEventListener("click", () => seekTo(b.start));
    const textEl = card.querySelector('[contenteditable="true"]');
    textEl.addEventListener("blur", () => {
      const newText = textEl.textContent.trim();
      if (newText !== b.text) {
        undoStack.push({ type: "edit", id: b.id, prevText: b.text });
        $undoBtn.disabled = false;
        b.text = newText;
        updateOriginalBlock(b.id);
        updateSummary();
      }
    });
    textEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); textEl.blur(); }
    });
  }

  card.addEventListener("click", (e) => {
    if (e.target.closest("button") || e.target.closest('[contenteditable="true"]')) return;
    seekTo(parseFloat(card.dataset.start));
  });
}

// ── Scroll Sync ──
function bindScrollSync() {
  function syncScroll(source, target) {
    if (scrollSyncing) return;
    scrollSyncing = true;
    const pct = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
    target.scrollTop = pct * (target.scrollHeight - target.clientHeight);
    requestAnimationFrame(() => { scrollSyncing = false; });
  }

  $originalPane.addEventListener("scroll", () => {
    if ($scrollSyncToggle.checked) syncScroll($originalPane, $editPane);
  });
  $editPane.addEventListener("scroll", () => {
    if ($scrollSyncToggle.checked) syncScroll($editPane, $originalPane);
  });
}

// ── Cut / Restore ──
function cutBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b || b.deleted) return;
  b.deleted = true;
  undoStack.push({ type: "cut", id: b.id });
  $undoBtn.disabled = false;

  updateEditBlock(id);
  updateOriginalBlock(id);
  updateSummary();
}

function restoreBlock(id) {
  const b = blocks.find(x => x.id === id);
  if (!b || !b.deleted) return;
  b.deleted = false;

  updateEditBlock(id);
  updateOriginalBlock(id);
  updateSummary();
}

function undoLast() {
  if (!undoStack.length) return;
  const action = undoStack.pop();
  $undoBtn.disabled = undoStack.length === 0;

  if (action.type === "cut") {
    restoreBlock(action.id);
  } else if (action.type === "edit") {
    const b = blocks.find(x => x.id === action.id);
    if (b) {
      b.text = action.prevText;
      updateEditBlock(action.id);
      updateOriginalBlock(action.id);
      updateSummary();
    }
  }
}

// ── Summary ──
function updateSummary() {
  const total = blocks.length;
  const removed = blocks.filter(b => b.deleted).length;
  const edited = blocks.filter(b => !b.deleted && b.text !== b.originalText).length;
  const cutDuration = blocks.filter(b => b.deleted).reduce((s, b) => s + (b.end - b.start), 0);
  const totalDuration = blocks.length ? blocks[blocks.length - 1].end : 0;
  const pct = totalDuration > 0 ? ((cutDuration / totalDuration) * 100).toFixed(1) : "0.0";

  document.getElementById("sumTotal").textContent = total;
  document.getElementById("sumRemoved").textContent = removed + (edited > 0 ? ` (+${edited} edited)` : "");
  document.getElementById("sumTimeCut").textContent = fmt(cutDuration);
  document.getElementById("sumReduction").textContent = pct + "%";
}

// ── Video sync ──
$videoPlayer.addEventListener("timeupdate", () => {
  if (!$syncToggle.checked) return;
  const t = $videoPlayer.currentTime;
  let active = -1;
  for (const b of blocks) {
    if (t >= b.start && t < b.end) { active = b.id; break; }
  }
  if (active === currentHighlight) return;
  currentHighlight = active;

  // Highlight in both panes
  [$originalPane, $editPane].forEach($pane => {
    $pane.querySelectorAll(".block-card.active").forEach(c => c.classList.remove("active"));
    if (active >= 0) {
      const card = $pane.querySelector(`[data-id="${active}"]`);
      if (card) card.classList.add("active");
    }
  });

  // Scroll the edit pane; original will follow via sync
  if (active >= 0 && $scrollSyncToggle.checked) {
    const card = $editPane.querySelector(`[data-id="${active}"]`);
    if (card) {
      const rect = card.getBoundingClientRect();
      const cRect = $editPane.getBoundingClientRect();
      if (rect.top < cRect.top + 40 || rect.bottom > cRect.bottom) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }
  }
});

function seekTo(time) {
  $videoPlayer.currentTime = time;
}

// ── Margin slider ──
$marginSlider.addEventListener("input", () => {
  $marginVal.textContent = parseFloat($marginSlider.value).toFixed(2) + "s";
});

// ── Advanced mode ──
function toggleAdvanced() {
  const panel = document.getElementById("advanced-panel");
  panel.classList.toggle("hidden");
  document.getElementById("advancedToggle").textContent =
    panel.classList.contains("hidden") ? "Advanced" : "Simple";
}

// ── Export ──
function startExport() {
  if (!videoPath) return;

  const $btn = document.getElementById("exportBtn");
  $btn.disabled = true;
  $btn.textContent = "Exporting\u2026";
  $exportResult.classList.add("hidden");

  // Send originalText for diff matching (so user edits don't break cut detection)
  const keptBlocks = blocks.filter(b => !b.deleted).map(b => ({
    index: b.index,
    start: b.start,
    end: b.end,
    text: b.originalText,
  }));

  fetch("/api/diff", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      orig_srt_path: origSrtPath,
      json_path: jsonPath,
      kept_blocks: keptBlocks,
    }),
  })
  .then(r => r.json())
  .then(diffData => {
    if (diffData.error) throw new Error(diffData.error);
    deletedRanges = diffData.deleted_ranges;

    if (diffData.summary) {
      const s = diffData.summary;
      document.getElementById("sumTotal").textContent = s.total_blocks;
      document.getElementById("sumRemoved").textContent = s.removed_blocks;
      document.getElementById("sumTimeCut").textContent = fmt(s.cut_duration);
      document.getElementById("sumReduction").textContent = s.reduction_pct + "%";
    }

    const payload = {
      video_path: videoPath,
      deleted_ranges: deletedRanges,
      margin: parseFloat($marginSlider.value),
      export: document.getElementById("exportFormat").value,
    };

    const silentSpeed = document.getElementById("silentSpeed").value.trim();
    const soundedSpeed = document.getElementById("soundedSpeed").value.trim();
    const videoCodec = document.getElementById("videoCodec").value.trim();
    const audioCodec = document.getElementById("audioCodec").value.trim();
    const ffmpegArgs = document.getElementById("ffmpegArgs").value.trim();
    const editMethod = document.getElementById("editMethod").value.trim();

    if (silentSpeed) payload.silent_speed = silentSpeed;
    if (soundedSpeed) payload.sounded_speed = soundedSpeed;
    if (videoCodec) payload.video_codec = videoCodec;
    if (audioCodec) payload.audio_codec = audioCodec;
    if (ffmpegArgs) payload.ffmpeg_args = ffmpegArgs;
    if (editMethod) payload.edit_method = editMethod;

    return fetch("/api/export", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
  })
  .then(r => r.json())
  .then(result => {
    $exportResult.classList.remove("hidden");
    if (result.success) {
      $exportResult.className = "success";
      $exportResult.textContent = `${result.message}\n\nCommand: ${result.command}`;
      if (result.stdout) $exportResult.textContent += `\n\n${result.stdout}`;
    } else {
      $exportResult.className = "error";
      $exportResult.textContent = `Export failed: ${result.error}\n\nCommand: ${result.command || "N/A"}`;
    }
  })
  .catch(err => {
    $exportResult.classList.remove("hidden");
    $exportResult.className = "error";
    $exportResult.textContent = "Error: " + err.message;
  })
  .finally(() => {
    $btn.disabled = false;
    $btn.textContent = "Export";
  });
}

// ── Keyboard shortcuts ──
document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable) return;
    e.preventDefault();
    undoLast();
  }
});
</script>
</body>
</html>
